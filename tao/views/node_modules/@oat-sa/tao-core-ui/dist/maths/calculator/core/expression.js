define(['lodash', 'ui/maths/calculator/core/terms', 'ui/maths/calculator/core/tokens', 'ui/maths/calculator/core/tokenizer', 'handlebars', 'i18n', 'lib/dompurify/purify'], function (_, registeredTerms, tokensHelper, tokenizerFactory, Handlebars, __, DOMPurify) { 'use strict';

  _ = _ && _.hasOwnProperty('default') ? _['default'] : _;
  registeredTerms = registeredTerms && registeredTerms.hasOwnProperty('default') ? registeredTerms['default'] : registeredTerms;
  tokensHelper = tokensHelper && tokensHelper.hasOwnProperty('default') ? tokensHelper['default'] : tokensHelper;
  tokenizerFactory = tokenizerFactory && tokenizerFactory.hasOwnProperty('default') ? tokenizerFactory['default'] : tokenizerFactory;
  Handlebars = Handlebars && Handlebars.hasOwnProperty('default') ? Handlebars['default'] : Handlebars;
  __ = __ && __.hasOwnProperty('default') ? __['default'] : __;
  DOMPurify = DOMPurify && DOMPurify.hasOwnProperty('default') ? DOMPurify['default'] : DOMPurify;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function Helpers0 (hb) {
    //register a i18n helper
    hb.registerHelper('__', function (key) {
      return __(key);
    });
    /**
     * Register dompurify helper
     *
     * https://github.com/cure53/DOMPurify
     * with config SAFE_FOR_TEMPLATES: true
     * to make output safe for template systems
     */

    hb.registerHelper('dompurify', function (context) {
      return DOMPurify.sanitize(context);
    });
    /**
     * Register join helper
     *
     * Example :
     * var values = {a:v1, b:v2, c:v3};
     * Using {{{join attributes '=' ' ' '"'}}} will return : a="v1" b="v2" c="v3"
     * Using {{{join values null ' or ' '*'}}} will return : *v1* or *v2* or *v3*
     */

    hb.registerHelper('join', function (arr, keyValueGlue, fragmentGlue, wrapper) {
      var fragments = [];
      keyValueGlue = typeof keyValueGlue === 'string' ? keyValueGlue : undefined;
      fragmentGlue = typeof fragmentGlue === 'string' ? fragmentGlue : ' ';
      wrapper = typeof wrapper === 'string' ? wrapper : '"';

      _.forIn(arr, function (value, key) {
        var fragment = '';

        if (value !== null || value !== undefined) {
          if (typeof value === 'boolean') {
            value = value ? 'true' : 'false';
          } else if (_typeof(value) === 'object') {
            value = _.values(value).join(' ');
          }
        } else {
          value = '';
        }

        if (keyValueGlue !== undefined) {
          fragment += key + keyValueGlue;
        }

        fragment += wrapper + value + wrapper;
        fragments.push(fragment);
      });

      return fragments.join(fragmentGlue);
    }); //register a classic "for loop" helper
    //it also adds a local variable "i" as the index in each iteration loop

    hb.registerHelper('for', function (startIndex, stopIndex, increment, options) {
      var ret = '';
      startIndex = parseInt(startIndex);
      stopIndex = parseInt(stopIndex);
      increment = parseInt(increment);

      for (var i = startIndex; i < stopIndex; i += increment) {
        ret += options.fn(_.extend({}, this, {
          i: i
        }));
      }

      return ret;
    });
    hb.registerHelper('equal', function (var1, var2, options) {
      if (var1 == var2) {
        return options.fn(this);
      } else {
        return options.inverse(this);
      }
    }); // register a "get property" helper
    // it gets the named property from the provided context

    hb.registerHelper('property', function (name, context) {
      return context[name] || '';
    }); // register an 'includes' helper
    // it checks if value is in array

    hb.registerHelper('includes', function (haystack, needle, options) {
      if (_.contains(haystack, needle)) {
        return options.fn(this);
      }
    });
  }

  if (!Helpers0.__initialized) {
    Helpers0(Handlebars);
    Helpers0.__initialized = true;
  }
  var Template = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
    this.compilerInfo = [4,'>= 1.0.0'];
  helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
    var stack1, self=this, functionType="function", escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = "", stack1, helper;
    stack1 = helpers.each.call(depth0, (depth0 && depth0.startExponent), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
    if(stack1 || stack1 === 0) { buffer += stack1; }
    buffer += "<span class=\"term term-";
    if (helper = helpers.type) { stack1 = helper.call(depth0, {hash:{},data:data}); }
    else { helper = (depth0 && depth0.type); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
    buffer += escapeExpression(stack1);
    stack1 = helpers['if'].call(depth0, (depth0 && depth0.elide), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
    if(stack1 || stack1 === 0) { buffer += stack1; }
    buffer += "\" data-value=\"";
    if (helper = helpers.value) { stack1 = helper.call(depth0, {hash:{},data:data}); }
    else { helper = (depth0 && depth0.value); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
    buffer += escapeExpression(stack1)
      + "\" data-token=\"";
    if (helper = helpers.token) { stack1 = helper.call(depth0, {hash:{},data:data}); }
    else { helper = (depth0 && depth0.token); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
    buffer += escapeExpression(stack1)
      + "\" data-type=\"";
    if (helper = helpers.type) { stack1 = helper.call(depth0, {hash:{},data:data}); }
    else { helper = (depth0 && depth0.type); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
    buffer += escapeExpression(stack1)
      + "\">";
    if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
    else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
    if(stack1 || stack1 === 0) { buffer += stack1; }
    buffer += "</span>";
    stack1 = helpers.each.call(depth0, (depth0 && depth0.endExponent), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
    if(stack1 || stack1 === 0) { buffer += stack1; }
    return buffer;
    }
  function program2(depth0,data) {
    
    
    return "<sup>";
    }

  function program4(depth0,data) {
    
    
    return " term-elide";
    }

  function program6(depth0,data) {
    
    
    return "</sup>";
    }

    stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
    if(stack1 || stack1 === 0) { return stack1; }
    else { return ''; }
    });
  function termsTpl(data, options, asString) {
    var html = Template(data, options);
    return (asString || true) ? html : $(html);
  }

  /**
   * This program is free software; you can redistribute it and/or
   * modify it under the terms of the GNU General Public License
   * as published by the Free Software Foundation; under version 2
   * of the License (non-upgradable).
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program; if not, write to the Free Software
   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
   *
   * Copyright (c) 2019 Open Assessment Technologies SA ;
   */
  /**
   * @typedef {term} renderTerm - Represents a renderable tokenizable term
   * @property {Array} startExponent - List of exponent starts (will produce exponent notation for the term)
   * @property {Array} endExponent - List of exponent ends (will finish exponent notation for the term)
   * @property {Boolean} prefixed - Tells if the term is prefixed (i.e. function treated as binary operator)
   * @property {Boolean} elide - Allows to hide the term when operands exist on each side
   */

  /**
   * Name of the variable that contains the last result
   * @type {String}
   */

  var lastResultVariableName = registeredTerms.ANS.value;
  /**
   * Regex that matches the prefixed function operators
   * @type {RegExp}
   */

  var rePrefixedTerm = /^@[a-zA-Z_]\w*$/;
  /**
   * Regex that matches the usual error tokens in a result
   * @type {RegExp}
   */

  var reErrorValue = /(NaN|[+-]?Infinity)/;
  /**
   * Regex that matches the last result variable
   * @type {RegExp}
   */

  var reAnsVar = new RegExp('\\b' + lastResultVariableName + '\\b', 'g');
  /**
   * List of tokens representing sign or sum
   * @type {String[]}
   */

  var signOperators = ['NEG', 'POS', 'SUB', 'ADD'];
  /**
   * List of tokens representing sub exponent parts to continue
   * @type {String[]}
   */

  var continueExponent = ['POW', 'NTHRT'];
  /**
   * Default number of significant digits used to round displayed variables
   * @type {Number}
   */

  var defaultDecimalDigits = 5;
  /**
   * List of helpers that apply on expression
   * @type {Object}
   */

  var expressionHelper = {
    /**
     * Checks if an expression contains an error token
     * @param {String|Number|Object} expression
     * @returns {Boolean}
     */
    containsError: function containsError(expression) {
      return reErrorValue.test(tokensHelper.stringValue(expression));
    },

    /**
     * Replace the last result variable by a particular value in an expression
     * @param {String|Number|Object} expression
     * @param {String|Number|Object} value
     * @returns {String}
     */
    replaceLastResult: function replaceLastResult(expression, value) {
      return tokensHelper.stringValue(expression).replace(reAnsVar, tokensHelper.stringValue(value || '0'));
    },

    /**
     * Rounds the value of a variable
     * @param {Object} variable
     * @param {Number} [decimalDigits=5]
     * @returns {String}
     */
    roundVariable: function roundVariable(variable, decimalDigits) {
      var resultString = tokensHelper.stringValue(variable);
      var fullString = resultString;
      var value = variable && variable.result;
      decimalDigits = decimalDigits || defaultDecimalDigits;

      if ('undefined' !== typeof value) {
        if (value.toExponential && resultString.indexOf(registeredTerms.EXP10.value) > 0) {
          resultString = value.toExponential(decimalDigits).toString();
        } else if (value.toDecimalPlaces && resultString.indexOf(registeredTerms.DOT.value) > 0) {
          resultString = value.toDecimalPlaces(decimalDigits).toString();
        }

        if (resultString.length < fullString.length) {
          resultString += registeredTerms.ELLIPSIS.value;
        } else {
          resultString = fullString;
        }
      }

      return resultString;
    },

    /**
     * Rounds the value of the last result variable
     * @param {Object} variables
     * @param {Number} [decimalDigits=5]
     * @returns {Object}
     */
    roundLastResultVariable: function roundLastResultVariable(variables, decimalDigits) {
      if (variables && 'undefined' !== typeof variables[lastResultVariableName]) {
        variables[lastResultVariableName] = expressionHelper.roundVariable(variables[lastResultVariableName], decimalDigits);
      }

      return variables;
    },

    /**
     * Replace sign operators by a proper symbol
     * @param {String|Number|Object} expression
     * @returns {String}
     */
    renderSign: function renderSign(expression) {
      return tokensHelper.stringValue(expression).replace(registeredTerms.SUB.value, registeredTerms.NEG.label).replace(registeredTerms.ADD.value, registeredTerms.POS.label);
    },

    /**
     * Renders an expression into a HTML string, using the display label of each extracted token .
     * @param {String|Number|Object|token[]} expression
     * @param {Object} [variables]
     * @param {calculatorTokenizer} [tokenizer]
     * @returns {String}
     */
    render: function render(expression, variables, tokenizer) {
      var tokens = expression;
      var exponents = [];
      var terms = [];
      var previous;
      /**
       * Transform an operator to a sign
       * @param {renderTerm} term
       * @param {String} token
       */

      function toSignOperator(term, token) {
        if (!previous || tokensHelper.isModifier(previous.type) || previous.token === 'LPAR' || previous.token === 'EXP10') {
          term.label = registeredTerms[token].label;
          term.token = token;
        }
      } // the expression might be already tokenized, if not we need to tokenize it


      if (!_.isArray(expression)) {
        // we need a valid tokenizer, so if none is provided we must build one
        if (!tokenizer || !tokenizer.tokenize) {
          tokenizer = tokenizerFactory();
        }

        tokens = tokenizer.tokenize(expression);
      }

      variables = variables || {}; // each token needs to be translated into a displayable term

      _.forEach(tokens, function (token, index) {
        var registeredTerm = registeredTerms[token.type];
        /**
         * @type {renderTerm}
         */

        var term = {
          type: token.type,
          token: token.type,
          value: token.value,
          label: token.value,
          description: token.value,
          exponent: null,
          startExponent: [],
          endExponent: [],
          prefixed: rePrefixedTerm.test(token.value),
          elide: false
        };

        if (registeredTerm) {
          _.merge(term, registeredTerm); // always display the actual value of the last result variable
          // also takes care of the value's sign


          if (term.value === lastResultVariableName && 'undefined' !== typeof variables[term.value]) {
            term.label = expressionHelper.render(variables[term.value], variables, tokenizer);
          }
        } else if (term.token === 'term') {
          // unspecified token can be a variable
          if ('undefined' !== typeof variables[term.value]) {
            term.type = 'variable';
          } else {
            term.type = 'unknown';
          }
        } // take care of the value's sign


        if (term.token === 'SUB') {
          toSignOperator(term, 'NEG');
        } else if (term.token === 'ADD') {
          toSignOperator(term, 'POS');
        }

        terms.push(term); // exponents will be processed in a second pass
        // for now we just need to keep track of the position

        if (term.exponent) {
          exponents.push(index);
        }

        previous = term;
      }); // if any exponent has been discovered, we need to process them now


      _.forEach(exponents, function (index) {
        var term = terms[index];

        if (term.exponent === 'left' && index > 0) {
          exponentOnTheLeft(index, terms);
        } else if (term.exponent === 'right' && index < terms.length - 1) {
          exponentOnTheRight(index, terms);
        }
      });

      return termsTpl(terms);
    }
  };
  /**
   * Search for the full operand on the left, then tag the edges with exponent flags
   * @param {Number} index
   * @param {renderTerm[]} terms
   */

  function exponentOnTheLeft(index, terms) {
    var parenthesis = 0;
    var next = terms[index];
    var term = terms[--index];
    /**
     * Simply moves the cursor to the next term to examine.
     * Here the move is made from the right to the left.
     */

    function nextTerm() {
      next = term;
      term = terms[--index];
    } // only take care of actual operand value or sub expression (starting from the right)


    if (term && (tokensHelper.isOperand(term.type) || term.token === 'RPAR')) {
      term.endExponent.push(term.endExponent.length);

      if (term.token === 'RPAR') {
        // closing parenthesis, we need to find the opening parenthesis
        parenthesis++;

        while (index > 0 && parenthesis > 0) {
          nextTerm();

          if (term.token === 'RPAR') {
            parenthesis++;
          } else if (term.token === 'LPAR') {
            parenthesis--;
          }
        } // a function could be attached to the sub expression, if so we must keep the link
        // however, the prefixed functions are particular as they act as a binary operators,
        // and therefore are not considered as function here


        if (index > 0 && tokensHelper.isFunction(terms[index - 1]) && !terms[index - 1].prefixed) {
          nextTerm();
        }
      } else if (tokensHelper.isDigit(term.type)) {
        // chain of digits should be treated as a single operand
        while (index && tokensHelper.isDigit(term.type)) {
          nextTerm();
        } // if the end of the chain has been overflown, we must step back one token


        if (!tokensHelper.isDigit(term.type)) {
          term = next;
        }
      }

      term.startExponent.push(term.startExponent.length);
    }
  }
  /**
   * Search for the full operand on the right, then tag the edges with exponent flags
   * @param {Number} index
   * @param {renderTerm[]} terms
   */


  function exponentOnTheRight(index, terms) {
    var last = terms.length - 1;
    var parenthesis = 0;
    var startAt = index;
    var previous = terms[index];
    var term = terms[++index];
    var shouldContinue;
    /**
     * Simply moves the cursor to the next term to examine.
     * Here the move is made from the left to the right.
     */

    function nextTerm() {
      previous = term;
      term = terms[++index];
    }
    /**
     * Simply moves back the cursor to the previous term.
     * Here the move is made from the right to the left.
     */


    function previousTerm() {
      term = previous;
      previous = terms[--index];
    } // only take care of actual operand value or sub expression (starting from the left)


    if (term && (tokensHelper.isOperand(term.type) || term.token === 'LPAR' || signOperators.indexOf(term.token) >= 0)) {
      term.startExponent.push(term.startExponent.length); // we use an internal loop as exponents could be chained

      do {
        shouldContinue = false; // functions are attached to an operand, and this link should be kept

        while (index < last && (tokensHelper.isFunction(term.type) || signOperators.indexOf(term.token) >= 0)) {
          nextTerm();
        } // if the end has been reached, step back one token


        if (!term) {
          previousTerm();
        }

        if (term.token === 'LPAR') {
          // opening parenthesis, we need to find the closing parenthesis
          parenthesis++;

          while (index < last && parenthesis > 0) {
            nextTerm();

            if (term.token === 'LPAR') {
              parenthesis++;
            } else if (term.token === 'RPAR') {
              parenthesis--;
            }
          }
        } else if (tokensHelper.isDigit(term.type)) {
          // chain of digits should be treated as a single operand
          while (index < last && tokensHelper.isDigit(term.type)) {
            nextTerm();
          } // if the end of the chain has been overflown, we must step back one token


          if (!term || !tokensHelper.isDigit(term.type)) {
            previousTerm();
          }
        } // factorial is a special case, as the operator can be placed either on the right or on the left
        // in any case it should be attached to its operand


        while (index < last && terms[index + 1].token === 'FAC') {
          nextTerm();
        } // sometimes a sub exponent continues the chain and should be part of the expression to put in exponent


        if (index < last && continueExponent.indexOf(terms[index + 1].token) >= 0) {
          // the next term should be ignored as we already know it is an exponent operator
          // then the term after have to be set as the current one
          nextTerm();
          nextTerm();
          shouldContinue = true;
        }
      } while (shouldContinue);

      term.endExponent.push(term.endExponent.length); // elide the operator if operands are complete

      if (startAt > 0 && startAt < last && terms[startAt].token === 'POW' && terms[startAt + 1].startExponent.length) {
        terms[startAt].elide = true;
      }
    }
  }

  return expressionHelper;

});
