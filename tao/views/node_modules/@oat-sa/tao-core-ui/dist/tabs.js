define(['jquery', 'lodash', 'ui/hider', 'ui/component', 'handlebars', 'i18n', 'lib/dompurify/purify', 'css!ui/tabs/css/tabs.css'], function ($$1, _, hider, componentFactory, Handlebars, __, DOMPurify, tabs_css) { 'use strict';

  $$1 = $$1 && $$1.hasOwnProperty('default') ? $$1['default'] : $$1;
  _ = _ && _.hasOwnProperty('default') ? _['default'] : _;
  hider = hider && hider.hasOwnProperty('default') ? hider['default'] : hider;
  componentFactory = componentFactory && componentFactory.hasOwnProperty('default') ? componentFactory['default'] : componentFactory;
  Handlebars = Handlebars && Handlebars.hasOwnProperty('default') ? Handlebars['default'] : Handlebars;
  __ = __ && __.hasOwnProperty('default') ? __['default'] : __;
  DOMPurify = DOMPurify && DOMPurify.hasOwnProperty('default') ? DOMPurify['default'] : DOMPurify;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function Helpers0 (hb) {
    //register a i18n helper
    hb.registerHelper('__', function (key) {
      return __(key);
    });
    /**
     * Register dompurify helper
     *
     * https://github.com/cure53/DOMPurify
     * with config SAFE_FOR_TEMPLATES: true
     * to make output safe for template systems
     */

    hb.registerHelper('dompurify', function (context) {
      return DOMPurify.sanitize(context);
    });
    /**
     * Register join helper
     *
     * Example :
     * var values = {a:v1, b:v2, c:v3};
     * Using {{{join attributes '=' ' ' '"'}}} will return : a="v1" b="v2" c="v3"
     * Using {{{join values null ' or ' '*'}}} will return : *v1* or *v2* or *v3*
     */

    hb.registerHelper('join', function (arr, keyValueGlue, fragmentGlue, wrapper) {
      var fragments = [];
      keyValueGlue = typeof keyValueGlue === 'string' ? keyValueGlue : undefined;
      fragmentGlue = typeof fragmentGlue === 'string' ? fragmentGlue : ' ';
      wrapper = typeof wrapper === 'string' ? wrapper : '"';

      _.forIn(arr, function (value, key) {
        var fragment = '';

        if (value !== null || value !== undefined) {
          if (typeof value === 'boolean') {
            value = value ? 'true' : 'false';
          } else if (_typeof(value) === 'object') {
            value = _.values(value).join(' ');
          }
        } else {
          value = '';
        }

        if (keyValueGlue !== undefined) {
          fragment += key + keyValueGlue;
        }

        fragment += wrapper + value + wrapper;
        fragments.push(fragment);
      });

      return fragments.join(fragmentGlue);
    }); //register a classic "for loop" helper
    //it also adds a local variable "i" as the index in each iteration loop

    hb.registerHelper('for', function (startIndex, stopIndex, increment, options) {
      var ret = '';
      startIndex = parseInt(startIndex);
      stopIndex = parseInt(stopIndex);
      increment = parseInt(increment);

      for (var i = startIndex; i < stopIndex; i += increment) {
        ret += options.fn(_.extend({}, this, {
          i: i
        }));
      }

      return ret;
    });
    hb.registerHelper('equal', function (var1, var2, options) {
      if (var1 == var2) {
        return options.fn(this);
      } else {
        return options.inverse(this);
      }
    }); // register a "get property" helper
    // it gets the named property from the provided context

    hb.registerHelper('property', function (name, context) {
      return context[name] || '';
    }); // register an 'includes' helper
    // it checks if value is in array

    hb.registerHelper('includes', function (haystack, needle, options) {
      if (_.contains(haystack, needle)) {
        return options.fn(this);
      }
    });
  }

  if (!Helpers0.__initialized) {
    Helpers0(Handlebars);
    Helpers0.__initialized = true;
  }
  var Template = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
    this.compilerInfo = [4,'>= 1.0.0'];
  helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
    var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

  function program1(depth0,data) {
    
    var buffer = "", stack1, helper;
    buffer += "\n    <li class=\"tab ";
    if (helper = helpers.cls) { stack1 = helper.call(depth0, {hash:{},data:data}); }
    else { helper = (depth0 && depth0.cls); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
    buffer += escapeExpression(stack1)
      + "\" data-tab-name=\"";
    if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
    else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
    buffer += escapeExpression(stack1)
      + "\">\n        <button class=\"action\" tabindex=\"0\" ";
    stack1 = helpers['if'].call(depth0, (depth0 && depth0.disabled), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
    if(stack1 || stack1 === 0) { buffer += stack1; }
    buffer += ">\n            ";
    stack1 = helpers['if'].call(depth0, (depth0 && depth0.icon), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
    if(stack1 || stack1 === 0) { buffer += stack1; }
    buffer += "\n            ";
    stack1 = helpers['if'].call(depth0, (depth0 && depth0.label), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
    if(stack1 || stack1 === 0) { buffer += stack1; }
    buffer += "\n        </button>\n    </li>\n    ";
    return buffer;
    }
  function program2(depth0,data) {
    
    
    return "disabled";
    }

  function program4(depth0,data) {
    
    var buffer = "", stack1, helper;
    buffer += "<span class=\"icon icon-";
    if (helper = helpers.icon) { stack1 = helper.call(depth0, {hash:{},data:data}); }
    else { helper = (depth0 && depth0.icon); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
    buffer += escapeExpression(stack1)
      + "\"></span>";
    return buffer;
    }

  function program6(depth0,data) {
    
    var buffer = "", stack1, helper;
    buffer += "<span class=\"label\">";
    if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
    else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
    buffer += escapeExpression(stack1)
      + "</span>";
    return buffer;
    }

    buffer += "<ul class=\"tab-group\">\n    ";
    stack1 = helpers.each.call(depth0, (depth0 && depth0.tabs), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
    if(stack1 || stack1 === 0) { buffer += stack1; }
    buffer += "\n</ul>\n";
    return buffer;
    });
  function tabsTpl(data, options, asString) {
    var html = Template(data, options);
    return (asString || true) ? html : $(html);
  }

  /**
   * @typedef {Object} tabsBarConfig
   * @property {String} [activeTab] - The name of the active tab
   * @property {Integer} [activeTabIndex] - the index of the tab to start on
   * @property {tabConfig[]} [tabs] - The list of tabs
   * @property {Boolean} [hideLoneTab] - Prevent to show the tabs when only one is registered
   * @property {jQuery|HTMLElement|String|Boolean} [showHideTarget] - Defines the container where to wire up tabs to
   * content, the link will be automatic, based on the data attribute `data-tab-content` that should match the tab name.
   * If the value is `true` the component's container will be used to find the panels.
   */

  /**
   * @typedef {Object} tabConfig
   * @property {Boolean} disabled - The tab is disabled
   * @property {String} name - The tab identifier
   * @property {String} label - The tab label
   * @property {String} [icon] - An optional tab icon
   * @property {String} [cls] - An optional CSS class name
   */

  /**
   * CSS class for the active tab
   * @type {String}
   */

  var activeTabCls = 'active';
  /**
   * CSS selector for the tabs
   * @type {String}
   */

  var tabSelector = '.tab';
  /**
   * CSS selector for the tab actions
   * @type {String}
   */

  var actionSelector = '.action';
  /**
   * Name of the attribute that contain the tab identifier
   * @type {String}
   */

  var tabNameAttr = 'data-tab-name';
  /**
   * Name of the attribute that contain the panel identifier
   * @type {String}
   */

  var panelNameAttr = 'data-tab-content';
  /**
   * Builds an instance of the tabs component.
   *
   * @example
   *  // activate by index
   *  const instance = tabsFactory($container, {
   *      tabs: [
   *          { label: 'TAO Local', name: 'local-delivery' },
   *          { label: 'TAO Remote', name: 'remote-delivery' },
   *          { label: 'LTI-based', name: 'lti-delivery', disabled: true }
   *      ],
   *      activeTabIndex: 1
   *  });
   *
   *  // activate by name
   *  const instance = tabsFactory($container, {
   *      tabs: [
   *          { label: 'TAO Local', name: 'local-delivery' },
   *          { label: 'TAO Remote', name: 'remote-delivery' },
   *          { label: 'LTI-based', name: 'lti-delivery', disabled: true }
   *      ],
   *      activeTab: 'remote-delivery'
   *  });
   *
   *  // link to panels
   *  const instance = tabsFactory($container, {
   *      showHideTarget: $panelContainer,
   *      tabs: [
   *          { label: 'TAO Local', name: 'local-delivery' },
   *          { label: 'TAO Remote', name: 'remote-delivery' },
   *          { label: 'LTI-based', name: 'lti-delivery', disabled: true }
   *      ]
   *  });
   *
   *  instance
   *      .on('ready', function onReady() {
   *          // the component is ready
   *      })
   *      .before('tabactivate', function beforeTabChange(e, name) {
   *          // a tab is being activated
   *          // it is possible to prevent its activation by returning a rejected promise
   *          if (name === 'lti-delivery') {
   *              return Promise.reject();
   *          }
   *      })
   *      .on('tabchange', function onTabChange(name) {
   *          // a tab has been activated
   *      });
   *
   * @param {HTMLElement|String} container
   * @param {tabsBarConfig} config
   * @param {String} [config.activeTab] - The name of the active tab
   * @param {Integer} [config.activeTabIndex] - the index of the tab to start on
   * @param {tabConfig[]} [config.tabs] - The list of tabs
   * @param {Boolean} [config.hideLoneTab] - Prevent to show the tabs when only one is registered
   * @param {jQuery|HTMLElement|String|Boolean} [config.showHideTarget] - Defines the container where to wire up tabs to
   * content, the link will be automatic, based on the data attribute `data-tab-content` that should match the tab name.
   * If the value is `true` the component's container will be used to find the panels.
   * @returns {tabsBarComponent}
   * @fires ready - When the component is ready to work
   * @fires error - When the component encounters issue
   * @fires tabactivate - Each time a tab must be activated
   * @fires tabchange - Each time a tab has been activated
   * @fires tabchange-${name} - Each time the named tab has been activated
   * @fires tabsupdate - Each time the tabs are updated
   */

  function tabsFactory(container, config) {
    // the list of displayed tabs
    var tabs = []; // the current active tab

    var activeTabName = null; // enable/disable elements

    var enableElement = function enableElement($el) {
      return $el.prop('disabled', false);
    };

    var disableElement = function disableElement($el) {
      return $el.prop('disabled', true);
    };
    /**
     * Gets a tab by its name
     * @param {String} name
     * @returns {tabConfig}
     */


    var findTabByName = function findTabByName(name) {
      return tabs.find(function (tab) {
        return tab.name === name;
      });
    };
    /**
     * Gets a tab by its name, throw a TypeError if the tab does not exist
     * @param {String} name - human-readable identifier
     * @returns {tabConfig}
     * @throws {TypeError} on invalid name param
     */


    var findTabByNameOrThrow = function findTabByNameOrThrow(name) {
      var tab = findTabByName(name);

      if (!tab) {
        throw new TypeError("No tab exists with the name: ".concat(name));
      }

      return tab;
    };
    /**
     * Initializes the tabs
     * @param {tabsBarComponent} component
     */


    var initTabs = function initTabs(component) {
      if (activeTabName) {
        var activeTab = activeTabName;
        activeTabName = null;
        component.setActiveTab(activeTab);
      }

      if (component.getConfig().hideLoneTab && tabs.length === 1) {
        hider.hide(component.getElement().find(tabSelector));
      }
    };
    /**
     * API of the tabs component
     * @exports ui/tabs
     */


    var tabsApi = {
      /**
       * Set new values for the tabs
       * @param {Array} newTabs
       * @returns {tabsBarComponent} instance
       * @throws {TypeError} on non-Array tabs
       * @fires tabsupdate once the tabs have been updated
       * @fires tabactivate once the active tab is updated
       */
      setTabs: function setTabs(newTabs) {
        if (!Array.isArray(newTabs)) {
          throw new TypeError('The provided tabs are not a valid array');
        }

        tabs = _toConsumableArray(newTabs); // reset tab to default if needed

        if (!activeTabName || !findTabByName(activeTabName)) {
          activeTabName = this.getDefaultActiveTab();
        } // replace the displayed tabs if already rendered


        if (this.is('rendered')) {
          var template = this.getTemplate();
          this.getElement().html($$1(template({
            tabs: tabs
          })).html()); // make sure the tab is selected and hide lone tab if needed

          initTabs(this);
        }
        /**
         * @event tabsupdate - Tabs have been updated
         * @param {Array} newTabs
         */


        this.trigger('tabsupdate', newTabs);
        return this;
      },

      /**
       * Retrieve internal tabs array
       * @returns {Array} tabs list
       */
      getTabs: function getTabs() {
        return _toConsumableArray(tabs);
      },

      /**
       * Gets the name of the active tab (if any)
       * @returns {String}
       */
      getActiveTab: function getActiveTab() {
        return activeTabName;
      },

      /**
       * Gets the index of the current active tab (if any)
       * @returns {Number}
       */
      getActiveTabIndex: function getActiveTabIndex() {
        return tabs.findIndex(function (tab) {
          return tab.name === activeTabName;
        });
      },

      /**
       * Gets the name of the default active tab
       * @returns {String|null}
       */
      getDefaultActiveTab: function getDefaultActiveTab() {
        var _this$getConfig = this.getConfig(),
            activeTab = _this$getConfig.activeTab,
            activeTabIndex = _this$getConfig.activeTabIndex;

        if (activeTab && findTabByName(activeTab)) {
          return activeTab;
        }

        if (typeof activeTabIndex === 'number' && tabs[activeTabIndex]) {
          return tabs[activeTabIndex].name;
        }

        return tabs.length && tabs[0].name || null;
      },

      /**
       * Activates a single tab by its name (deactivating others)
       * @param {String} name - human-readable identifier
       * @returns {tabsBarComponent} instance
       * @throws {TypeError} on invalid name param
       * @fires tabactivate
       */
      setActiveTab: function setActiveTab(name) {
        var tab = findTabByNameOrThrow(name);

        if (!tab.disabled) {
          /**
           * @event tabactivate - A tab is being activated
           * @param {String} - name
           */
          this.trigger('tabactivate', tab.name);
        }

        return this;
      },

      /**
       * Activates a single tab by its index (deactivating others)
       * Triggers the automatic showing & hiding of target tab-contents
       * @param {Number} index - zero-based
       * @returns {tabsBarComponent} instance
       * @throws {TypeError} on invalid index param
       * @fires tabactivate
       */
      setActiveTabIndex: function setActiveTabIndex(index) {
        if (typeof index !== 'number' || index < 0 || index >= tabs.length) {
          throw new TypeError("No tab exists at index: ".concat(index));
        }

        var tab = tabs[index];

        if (!tab.disabled) {
          /**
           * @event tabactivate - A tab is being activated
           * @param {String} - name
           */
          this.trigger('tabactivate', tab.name);
        }

        return this;
      },

      /**
       * Enables a single tab by its name
       * @param {String} name - human-readable identifier
       * @returns {tabsBarComponent} instance
       * @throws {TypeError} on invalid name param
       * @fires tabenable
       */
      enableTab: function enableTab(name) {
        var tab = findTabByNameOrThrow(name);
        tab.disabled = false;

        if (this.is('rendered')) {
          enableElement(this.getElement().find("[".concat(tabNameAttr, "=\"").concat(name, "\"] ").concat(actionSelector)));
        }
        /**
         * @event tabenable - A tab is enabled
         * @param {String} - name
         */


        this.trigger('tabenable', name);
        return this;
      },

      /**
       * Disables a single tab by its name
       * @param {String} name - human-readable identifier
       * @returns {tabsBarComponent} instance
       * @throws {TypeError} on invalid name param
       * @fires tabdisable
       */
      disableTab: function disableTab(name) {
        var tab = findTabByNameOrThrow(name);
        tab.disabled = true;

        if (this.is('rendered')) {
          disableElement(this.getElement().find("[".concat(tabNameAttr, "=\"").concat(name, "\"] ").concat(actionSelector)));
        }
        /**
         * @event tabdisable - A tab is disabled
         * @param {String} - name
         */


        this.trigger('tabdisable', name);
      },

      /**
       * Shows one tab content, hides the rest
       * The tab content elements are not tied to any template and can be located anywhere in the DOM
       * @param {String} name - human-readable identifier
       * @throws {TypeError} on invalid name param
       * @fires tabshowcontent
       */
      showTabContent: function showTabContent(name) {
        findTabByNameOrThrow(name);

        var _this$getConfig2 = this.getConfig(),
            showHideTarget = _this$getConfig2.showHideTarget;

        if (showHideTarget) {
          (showHideTarget === true ? this.getContainer() : $$1(showHideTarget)).find("[".concat(panelNameAttr, "]")).addClass('hidden').filter("[".concat(panelNameAttr, "=\"").concat(name, "\"]")).removeClass('hidden');
        }
        /**
         * @event tabshowcontent - A tab panel is displayed
         * @param {String} - name
         */


        this.trigger('tabshowcontent', name);
      }
    };
    /**
     * @typedef {component} tabsBarComponent
     */

    var tabsBarComponent = componentFactory(tabsApi) // set the component's layout
    .setTemplate(tabsTpl) // auto render on init
    .on('init', function onTabsBarInit() {
      var _this = this;

      try {
        // extract the tabs from the config
        if (this.config && this.config.tabs) {
          this.setTabs(this.config.tabs);
        } // auto render on init (defer the call to give a chance to the init event to be completed before)


        _.defer(function () {
          return _this.render(container);
        });
      } catch (err) {
        /**
         * @event error
         * @param {Error} err
         */
        this.trigger('error', err);
      }
    }) // renders the component
    .on('render', function onTabsBarRender() {
      var _this2 = this;

      try {
        // make sure the tab is selected and hide lone tab if needed
        initTabs(this);
      } catch (err) {
        /**
         * @event error
         * @param {Error} err
         */
        this.trigger('error', err);
      } // delegate the click on tabs


      this.getElement().on('click', tabSelector, function (e) {
        try {
          _this2.setActiveTab(e.currentTarget.getAttribute(tabNameAttr));
        } catch (err) {
          /**
           * @event error
           * @param {Error} err
           */
          _this2.trigger('error', err);
        }
      });
      /**
       * @event ready - The component is ready to work
       */

      this.trigger('ready');
    }) // take care of the disable state
    .on('disable', function onButtonDisable() {
      if (this.is('rendered')) {
        disableElement(this.getElement().find("[".concat(tabNameAttr, "] ").concat(actionSelector)));
      }
    }).on('enable', function onButtonEnable() {
      if (this.is('rendered')) {
        this.getElement().find("[".concat(tabNameAttr, "] ").concat(actionSelector)).each(function (index, el) {
          var tab = findTabByName(el.parentNode.getAttribute(tabNameAttr));

          if (!tab || !tab.disabled) {
            el.disabled = false;
          }
        });
      }
    }) // reacts to tab activate
    .on('tabactivate', function onTabActivate(name) {
      var tab = findTabByName(name);

      if (tab && !tab.disabled && name !== activeTabName) {
        activeTabName = name;

        if (this.is('rendered')) {
          this.getElement().find(tabSelector).removeClass(activeTabCls).filter("[".concat(tabNameAttr, "=\"").concat(name, "\"]")).addClass(activeTabCls);
        }
        /**
         * @event tabchange - A tab is activated
         * @param {String} - name
         */


        this.trigger('tabchange', name);
      }
    }) // reacts to tab change
    .on('tabchange', function onTabChange(name) {
      // auto show the linked panel
      if (this.getConfig().showHideTarget) {
        this.showTabContent(name);
      }
      /**
       * @event tabchange-${name} - The tab is activated
       */


      this.trigger("tabchange-".concat(name));
    }); // initialize the component with the provided config
    // defer the call to allow to listen to the init event

    _.defer(function () {
      return tabsBarComponent.init(config);
    });

    return tabsBarComponent;
  }

  return tabsFactory;

});
