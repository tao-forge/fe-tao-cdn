define(['jquery', 'lodash', 'i18n', 'module', 'context', 'core/promiseQueue', 'core/tokenHandler', 'core/logger'], function ($, _, __, module, context, promiseQueue, tokenHandlerFactory, loggerFactory) { 'use strict';

  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;
  _ = _ && _.hasOwnProperty('default') ? _['default'] : _;
  __ = __ && __.hasOwnProperty('default') ? __['default'] : __;
  module = module && module.hasOwnProperty('default') ? module['default'] : module;
  context = context && context.hasOwnProperty('default') ? context['default'] : context;
  promiseQueue = promiseQueue && promiseQueue.hasOwnProperty('default') ? promiseQueue['default'] : promiseQueue;
  tokenHandlerFactory = tokenHandlerFactory && tokenHandlerFactory.hasOwnProperty('default') ? tokenHandlerFactory['default'] : tokenHandlerFactory;
  loggerFactory = loggerFactory && loggerFactory.hasOwnProperty('default') ? loggerFactory['default'] : loggerFactory;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var tokenHeaderName = 'X-CSRF-Token';
  var tokenHandler = tokenHandlerFactory();
  var queue = promiseQueue();
  var logger = loggerFactory('core/request');
  /**
   * Create a new error based on the given response
   * @param {Object} response - the server body response as plain object
   * @param {String} fallbackMessage - the error message in case the response isn't correct
   * @param {Number} httpCode - the response HTTP code
   * @param {Boolean} httpSent - the sent status
   * @returns {Error} the new error
   */

  var createError = function createError(response, fallbackMessage, httpCode, httpSent) {
    var err;

    if (response && response.errorCode) {
      err = new Error("".concat(response.errorCode, " : ").concat(response.errorMsg || response.errorMessage || response.error));
    } else {
      err = new Error(fallbackMessage);
    }

    err.response = response;
    err.sent = httpSent;
    err.source = response.source || 'request';

    if (_.isNumber(httpCode)) {
      err.code = httpCode;
    }

    return err;
  };
  /**
   * Request content from a TAO endpoint
   * @param {Object} options
   * @param {String} options.url - the endpoint full url
   * @param {String} [options.method='GET'] - the HTTP method
   * @param {Object} [options.data] - additional parameters (if method is 'POST')
   * @param {Object} [options.headers] - the HTTP headers
   * @param {String} [options.contentType] - what kind of data we're sending - usually 'json'
   * @param {String} [options.dataType] - what kind of data expected in response
   * @param {Boolean} [options.noToken=false] - by default, a token is always sent. If noToken=true, disables the token requirement
   * @param {Boolean} [options.background] - if true, the request should be done in the background, which in practice does not trigger the global handlers like ajaxStart or ajaxStop
   * @param {Boolean} [options.sequential] - if true, the request must join a queue to be run sequentially
   * @param {Number}  [options.timeout] - timeout in seconds for the AJAX request
   * @param {Object} [options.jwtTokenHandler] - JWT token handler instance
   * @param {string} [options.logLevel] - Minimum log level for request
   * @returns {Promise} resolves with response, or reject if something went wrong
   */


  function request(options) {
    var _this = this;

    // Allow external config to override user option
    if (module.config().noToken) {
      options.noToken = true;
    }

    if (_.isEmpty(options.url)) {
      throw new TypeError('At least give a URL...');
    } // Request logger


    var requestLogger = logger.child({
      url: options.url
    });
    var logLevel = options.logLevel;

    if (logLevel) {
      requestLogger.level(logLevel);
    }
    /**
     * Function wrapper which allows the contents to be run now, or added to a queue
     * @returns {Promise} resolves with response, or rejects if something went wrong
     */


    var runRequest = function runRequest() {
      var tempToken;
      /**
       * Fetches a security token and appends it to headers, if required
       * Also saves the retrieved token in a temporary constiable, in case we need to re-enqueue it
       * @returns {Promise<Object>} - resolves with headers object
       */

      var computeCSRFTokenHeader = function computeCSRFTokenHeader() {
        if (options.noToken) {
          return Promise.resolve({});
        }

        return tokenHandler.getToken().then(function (token) {
          tempToken = token;
          return _defineProperty({}, tokenHeaderName, token || 'none');
        });
      };
      /**
       * Fetches a JWT token if token handler is provided
       * @returns {Promise<Object>} promise of JWT token header
       */


      var computeJWTTokenHeader = function computeJWTTokenHeader() {
        var jwtTokenHandler = options.jwtTokenHandler;

        if (jwtTokenHandler) {
          return jwtTokenHandler.getToken().then(function (token) {
            return {
              Authorization: "Bearer ".concat(token)
            };
          });
        }

        return Promise.resolve({});
      };
      /**
       * Extends header object with token headers
       * @returns {Promise<Object>} Promise of headers object
       */


      var computeHeaders = function computeHeaders() {
        return Promise.all([computeCSRFTokenHeader(), computeJWTTokenHeader()]).then(function (_ref2) {
          var _ref3 = _slicedToArray(_ref2, 2),
              csrfTokenHeader = _ref3[0],
              jwtTokenHeader = _ref3[1];

          return Object.assign({}, options.headers, csrfTokenHeader, jwtTokenHeader);
        });
      };
      /**
       * Replaces the locally-stored tempToken into the tokenStore
       * Unsets the local copy
       * @returns {Promise} - resolves when done
       */


      var reEnqueueTempToken = function reEnqueueTempToken() {
        if (tempToken) {
          requestLogger.debug('re-enqueueing %s token %s', tokenHeaderName, tempToken);
          return tokenHandler.setToken(tempToken).then(function () {
            tempToken = null;
          });
        }

        return Promise.resolve();
      };
      /**
       * Extracts returned security token from headers and adds it to store
       * @param {Object} xhr
       * @returns {Promise} - resolves when done
       */


      var setTokenFromXhr = function setTokenFromXhr(xhr) {
        if (_.isFunction(xhr.getResponseHeader)) {
          var token = xhr.getResponseHeader(tokenHeaderName);
          requestLogger.debug('received %s header %s', tokenHeaderName, token);

          if (token) {
            return tokenHandler.setToken(token);
          }
        }

        return Promise.resolve();
      };
      /**
       * Contains the request already tried to refresh the invalid access token
       */


      var isAccessTokenRefreshTried = false;
      return computeHeaders().then(function (customHeaders) {
        return new Promise(function (resolve, reject) {
          var noop = void 0;
          var ajaxParameters = {
            url: options.url,
            method: options.method || 'GET',
            headers: customHeaders,
            data: options.data,
            contentType: options.contentType || noop,
            dataType: options.dataType || 'json',
            async: true,
            timeout: options.timeout * 1000 || context.timeout * 1000 || 0,
            beforeSend: function beforeSend() {
              if (!_.isEmpty(customHeaders)) {
                requestLogger.debug('sending %s header %s', tokenHeaderName, customHeaders && customHeaders[tokenHeaderName]);
              }
            },
            global: !options.background //TODO fix this with TT-260

          };

          var onDone = function onDone(response, status, xhr) {
            setTokenFromXhr(xhr).then(function () {
              if (xhr.status === 204 || response && response.errorCode === 204 || status === 'nocontent') {
                // no content, so resolve with empty data.
                return resolve();
              } // handle case where token expired or invalid


              if (xhr.status === 403 || response && response.errorCode === 403) {
                return reject(createError(response, "".concat(xhr.status, " : ").concat(xhr.statusText), xhr.status, xhr.readyState > 0));
              }

              if (xhr.status === 200 || response && response.success === true) {
                // there's some data
                return resolve(response);
              } //the server has handled the error


              reject(createError(response, __('The server has sent an empty response'), xhr.status, xhr.readyState > 0));
            }).catch(function (error) {
              requestLogger.error(error);
              reject(createError(response, error, xhr.status, xhr.readyState > 0));
            });
          };

          var onFail = function onFail(xhr, textStatus, errorThrown) {
            var response;
            var jwtTokenHandler = options.jwtTokenHandler;
            /**
                 * if access token expired then
                 * get new token
                 * update header with new token
                 * retry request
                 *  */

            if (xhr.status === 401 && !isAccessTokenRefreshTried && jwtTokenHandler) {
              isAccessTokenRefreshTried = true;
              jwtTokenHandler.refreshToken().then(computeJWTTokenHeader).then(function (jwtTokenHeaders) {
                Object.assign(ajaxParameters.headers, jwtTokenHeaders);
                $.ajax(ajaxParameters).done(onDone).fail(onFail);
              }) // if refresh token was not success, fail with original error
              .catch(function () {
                onFail(xhr, textStatus, errorThrown);
              });
              return;
            }

            try {
              response = JSON.parse(xhr.responseText);
            } catch (parseErr) {
              response = {};
            }

            var responseExtras = {
              success: false,
              source: 'network',
              cause: options.url,
              purpose: 'proxy',
              context: _this,
              code: xhr.status,
              sent: xhr.readyState > 0,
              type: 'error',
              textStatus: textStatus,
              message: errorThrown || __('An error occurred!')
            };
            var enhancedResponse = Object.assign({}, responseExtras, response); // if the request failed because the browser is offline,
            // we need to recycle the used request token

            var tokenHandlerPromise;

            if (enhancedResponse.code === 0) {
              tokenHandlerPromise = reEnqueueTempToken();
            } else {
              tokenHandlerPromise = setTokenFromXhr(xhr);
            }

            tokenHandlerPromise.then(function () {
              reject(createError(enhancedResponse, "".concat(xhr.status, " : ").concat(xhr.statusText), xhr.status, xhr.readyState > 0));
            }).catch(function (error) {
              requestLogger.error(error);
              reject(createError(enhancedResponse, error, xhr.status, xhr.readyState > 0));
            });
          };

          $.ajax(ajaxParameters).done(onDone).fail(onFail);
        });
      });
    }; // Decide how to launch the request based on certain params:


    return tokenHandler.getQueueLength().then(function (queueLength) {
      if (options.noToken === true) {
        // no token protection, run the request
        return runRequest();
      } else if (options.sequential || queueLength === 1) {
        // limited tokens, sequential queue must be used
        return queue.serie(runRequest);
      } else {
        // tokens ready
        return runRequest();
      }
    });
  }

  return request;

});
