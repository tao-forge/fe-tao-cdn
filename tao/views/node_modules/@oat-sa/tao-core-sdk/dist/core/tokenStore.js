define(['lodash', 'core/store'], function (_, store) { 'use strict';

    _ = _ && _.hasOwnProperty('default') ? _['default'] : _;
    store = store && store.hasOwnProperty('default') ? store['default'] : store;

    /*
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2019 Open Assessment Technologies SA
     */
    /**
     * @typedef {Object} token - A token object
     * @property {String} value - Long alphanumeric string
     * @property {Number} receivedAt - Creation timestamp
     */

    var defaultConfig = {
      maxSize: 6,
      // Default number of tokens to store
      tokenTimeLimit: 1000 * 60 * 24,
      // Default token TTL (24 minutes)
      store: 'memory' // In memory storage is preferred by default over the indexeddb or localStorage implementations

    };
    /**
     * Create a token store
     * @param {Object} [options]
     * @param {Number} [options.maxSize = 6] - the store limit
     * @param {Number} [options.tokenTimeLimit] - time in milliseconds each token remains valid for
     * @returns {tokenStore}
     */

    function tokenStoreFactory(options) {
      var config = _.defaults(options || {}, defaultConfig);

      var getStoreBackend = function getStoreBackend() {
        return store.backends[config.store] || store.backends[defaultConfig.store];
      };

      var getStore = function getStore() {
        return store('tokenStore.tokens', getStoreBackend());
      };
      /**
       * @typedef tokenStore
       */


      return {
        /**
         * Get the oldest token from the queue
         * Remove its store entry as well
         *
         * @returns {Promise<Object>} the token object
         */
        dequeue: function dequeue() {
          var _this = this;

          return this.getIndex().then(function (latestIndex) {
            var key = _.first(latestIndex);

            if (!key) {
              return Promise.resolve();
            }

            return getStore().then(function (storage) {
              return storage.getItem(key);
            }).then(function (token) {
              return _this.remove(key).then(function () {
                return token;
              });
            });
          });
        },

        /**
         * Add a new token object to the queue
         * Add an entry to the store as well
         *
         * @param {token} token - the token object
         * @param {String} token.value - long alphanumeric string
         * @param {Number} token.receivedAt - timestamp
         * @returns {Promise<Boolean>} - true if added
         */
        enqueue: function enqueue(token) {
          var _this2 = this;

          // Handle legacy param type:
          if (_.isString(token)) {
            token = {
              value: token,
              receivedAt: Date.now()
            };
          }

          return getStore().then(function (storage) {
            return storage.setItem(token.value, token);
          }).then(function (updated) {
            if (updated) {
              return _this2.enforceMaxSize().then(function () {
                return true;
              });
            }

            return false;
          });
        },

        /**
         * Generate a new (chronologically-sorted) index from the store contents
         * (because it would not be unique if stored in the module)
         *
         * @returns {Promise<Array>}
         */
        getIndex: function getIndex() {
          return this.getTokens().then(function (tokens) {
            return Object.values(tokens).sort(function (t1, t2) {
              return t1.receivedAt - t2.receivedAt;
            }).map(function (token) {
              return token.value;
            });
          });
        },

        /**
         * Check whether the given token is in the store
         *
         * @param {String} key - token string
         * @returns {Promise<Boolean>}
         */
        has: function has(key) {
          return this.getIndex().then(function (latestIndex) {
            return latestIndex.includes(key);
          });
        },

        /**
         * Remove the token from the queue and the store
         *
         * @param {String} key - token string
         * @returns {Promise<Boolean>} resolves once removed
         */
        remove: function remove(key) {
          return this.has(key).then(function (result) {
            if (result) {
              return getStore().then(function (storage) {
                return storage.removeItem(key);
              });
            }

            return false;
          });
        },

        /**
         * Empty the queue and store
         * @returns {Promise}
         */
        clear: function clear() {
          return getStore().then(function (storage) {
            return storage.clear();
          });
        },

        /**
         * Gets all tokens in the store
         * @returns {Promise<Array>} - token objects
         */
        getTokens: function getTokens() {
          return getStore().then(function (storage) {
            return storage.getItems();
          });
        },

        /**
         * Gets the current size of the store
         * @returns {Promise<Number>}
         */
        getSize: function getSize() {
          return this.getIndex().then(function (latestIndex) {
            return latestIndex.length;
          });
        },

        /**
         * Setter for maximum pool size
         * @param {Number} size
         */
        setMaxSize: function setMaxSize(size) {
          if (_.isNumber(size) && size > 0 && size !== config.maxSize) {
            config.maxSize = size;
            this.enforceMaxSize();
          }
        },

        /**
         * Removes oldest tokens, if the pool is above its size limit
         * (Could happen if maxSize is reduced during the life of the tokenStore)
         * @returns {Promise} - resolves when done
         */
        enforceMaxSize: function enforceMaxSize() {
          var _this3 = this;

          return this.getIndex().then(function (latestIndex) {
            var excess = latestIndex.length - config.maxSize;

            if (excess > 0) {
              var keysToRemove = latestIndex.slice(0, excess);
              return Promise.all(keysToRemove.map(function (key) {
                return _this3.remove(key);
              }));
            }

            return true;
          });
        },

        /**
         * Checks one token and removes it from the store if expired.
         * If the timeLimit is lesser than or equal to 0, no time limit is applied.
         * @param {token} token - the token object
         * @returns {Promise<Boolean>}
         */
        checkExpiry: function checkExpiry(token) {
          var tokenTimeLimit = config.tokenTimeLimit;

          if (tokenTimeLimit > 0 && Date.now() - token.receivedAt > tokenTimeLimit) {
            return this.remove(token.value);
          }

          return Promise.resolve(true);
        },

        /**
         * Checks all the tokens in the store to see if they expired
         * @returns {Promise<Boolean>} - resolves to true
         */
        expireOldTokens: function expireOldTokens() {
          var _this4 = this;

          return this.getTokens() // Check each token's expiry, synchronously:
          .then(function (tokens) {
            return Object.values(tokens).reduce(function (previousPromise, nextToken) {
              return previousPromise.then(function () {
                return _this4.checkExpiry(nextToken);
              });
            }, Promise.resolve());
          }) // All done
          .then(function () {
            return true;
          });
        }
      };
    }

    return tokenStoreFactory;

});
