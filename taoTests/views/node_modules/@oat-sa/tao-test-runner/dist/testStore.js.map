{"version":3,"file":"testStore.js","sources":["../src/testStore.js"],"sourcesContent":["/*\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; under version 2\n * of the License (non-upgradable).\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * Copyright (c) 2017-2019 (original work) Open Assessment Technologies SA\n *\n */\n\n/**\n * The test runner persistent data store,\n * to be used with sub stores.\n *\n * Supports the legacy mode where multiple stores were used by each plugin.\n *\n * @author Bertrand Chevrier <bertrand@taotesting.com>\n */\nimport _ from 'lodash';\nimport store from 'core/store';\nimport loggerFactory from 'core/logger';\n\n/**\n * The test store logger\n * @type {core/logger}\n */\nvar logger = loggerFactory('taoQtiTest/runner/provider/testStore');\n\n/**\n * Database name prefix (suffixed by the test identifier)\n * to check if we use the fragmented mode\n * or the unified mode.\n * @type {String[]}\n */\nvar legacyPrefixes = ['actions-', 'duration-', 'test-probe', 'timer-'];\n\n/**\n * List the available modes\n */\nvar modes = {\n    unified: 'unified', //one db per test, new mode\n    fragmented: 'fragmented' //mutliple dbs per test, legacy mode\n};\n\n/**\n * Check and select the store mode.\n * If any of the \"legacyPrefixes\" store is found, we used the fragmented mode\n * otherwise we'll use the unified mode.\n * @param {String} testId\n * @param {Object} [preselectedBackend] - the storage backend\n * @returns {Promise<String>} resolves with the mode of the current test\n */\nvar selectStoreMode = function selectStoreMode(testId, preselectedBackend) {\n    return store\n        .getAll(function validate(storeName) {\n            return _.some(legacyPrefixes, function(prefix) {\n                return !_.isEmpty(storeName) && prefix + testId === storeName;\n            });\n        }, preselectedBackend)\n        .then(function(foundStores) {\n            if (_.isArray(foundStores) && foundStores.length > 0) {\n                return modes.fragmented;\n            }\n            return modes.unified;\n        });\n};\n\n/**\n * Get the store for the given test\n *\n * @param {String} testId - unique test instance id\n * @returns {testStore} a 'wrapped' store instance\n * @param {Object} [preselectedBackend] - the storage backend (automatically selected by default)\n * @throws {TypeError} without a testId\n */\nexport default function testStoreLoader(testId, preselectedBackend) {\n    var storeNames = [];\n    var volatiles = [];\n    var changeTracking = {};\n    var testMode;\n\n    /**\n     * Is the test using a unified store mode ?\n     * @returns {Promise<Boolean>} true if unified\n     */\n    var isStoreModeUnified = function isStoreModeUnified() {\n        if (_.isUndefined(testMode)) {\n            return selectStoreMode(testId, preselectedBackend).then(function(result) {\n                if (result && typeof modes[result] !== 'undefined') {\n                    testMode = result;\n                } else {\n                    //use the unified mode by default\n                    testMode = modes.unified;\n                }\n\n                logger.debug(`Test store mode ${result} for ${testId}`);\n                return result === modes.unified;\n            });\n        }\n        return Promise.resolve(testMode === modes.unified);\n    };\n\n    if (_.isEmpty(testId)) {\n        throw new TypeError('The store must be identified with a unique test identifier');\n    }\n\n    /**\n     * Wraps a store and add the support of \"volatile\" storages\n     * @typedef {Object} testStore\n     */\n    return {\n        /**\n         * Get a wrapped store instance, that let's you use multiple stores inside one store...\n         * (or in multiple stores if the test is in legacy mode)\n         * @param {String} storeName - the name of the sub store\n         * @returns {Promise<storage>}\n         */\n        getStore: function getStore(storeName) {\n            //call when the current storge has been changed\n            //only if the store is set to track changes\n            var trackChange = function trackChange() {\n                if (_.isBoolean(changeTracking[storeName])) {\n                    changeTracking[storeName] = true;\n                }\n            };\n\n            if (_.isEmpty(storeName)) {\n                throw new TypeError('A store name must be provided to get the store');\n            }\n\n            if (!_.contains(storeNames, storeName)) {\n                storeNames.push(storeName);\n            }\n            return isStoreModeUnified().then(function(isUnified) {\n                var loadStore;\n                if (isUnified) {\n                    loadStore = store(testId, preselectedBackend);\n                } else {\n                    loadStore = store(`${storeName}-${testId}`, preselectedBackend);\n                }\n\n                return loadStore.then(function(loadedStore) {\n                    var keyPattern = new RegExp(`^${storeName}__`);\n                    var storeKey = function storeKey(key) {\n                        return isUnified ? `${storeName}__${key}` : key;\n                    };\n\n                    /**\n                     * The wrapped storage\n                     * @type {Object}\n                     */\n                    return {\n                        /**\n                         * Get an item with the given key\n                         * @param {String} key\n                         * @returns {Promise<*>} with the result in resolve, undefined if nothing\n                         */\n                        getItem: function getItem(key) {\n                            return loadedStore.getItem(storeKey(key));\n                        },\n\n                        /**\n                         * Get all store items\n                         * @returns {Promise<Object>} with a collection of items\n                         */\n                        getItems: function getItems() {\n                            if (isUnified) {\n                                return loadedStore.getItems().then(function(entries) {\n                                    return _.transform(\n                                        entries,\n                                        function(acc, entry, key) {\n                                            if (keyPattern.test(key)) {\n                                                acc[key.replace(keyPattern, '')] = entry;\n                                            }\n                                            return acc;\n                                        },\n                                        {}\n                                    );\n                                });\n                            } else {\n                                return loadedStore.getItems();\n                            }\n                        },\n\n                        /**\n                         * Set an item with the given key\n                         * @param {String} key - the item key\n                         * @param {*} value - the item value\n                         * @returns {Promise<Boolean>} with true in resolve if added/updated\n                         */\n                        setItem: function setItem(key, value) {\n                            trackChange();\n                            return loadedStore.setItem(storeKey(key), value);\n                        },\n\n                        /**\n                         * Remove an item with the given key\n                         * @param {String} key - the item key\n                         * @returns {Promise<Boolean>} with true in resolve if removed\n                         */\n                        removeItem: function removeItem(key) {\n                            trackChange();\n                            return loadedStore.removeItem(storeKey(key));\n                        },\n\n                        /**\n                         * Clear the current store\n                         * @returns {Promise<Boolean>} with true in resolve once cleared\n                         */\n                        clear: function clear() {\n                            trackChange();\n                            if (isUnified) {\n                                return loadedStore.getItems().then(function(entries) {\n                                    _.forEach(entries, function(entry, key) {\n                                        if (keyPattern.test(key)) {\n                                            loadedStore.removeItem(key);\n                                        }\n                                    });\n                                });\n                            } else {\n                                return loadedStore.clear();\n                            }\n                        }\n                    };\n                });\n            });\n        },\n\n        /**\n         * Define the given store as \"volatile\".\n         * It means the store data can be revoked\n         * if the user change browser for example\n         * @param {String} storeName - the name of the store to set as volatile\n         * @returns {testStore} chains\n         */\n        setVolatile: function setVolatile(storeName) {\n            if (!_.contains(volatiles, storeName)) {\n                volatiles.push(storeName);\n            }\n            return this;\n        },\n\n        /**\n         * Check the given storeId. If different from the current stored identifier\n         * we initiate the invalidation of the volatile data.\n         * @param {String} storeId - the id to check\n         * @returns {Promise<Boolean>} true if cleared\n         */\n        clearVolatileIfStoreChange: function clearVolatileIfStoreChange(storeId) {\n            var self = this;\n            var shouldClear = false;\n            return store\n                .getIdentifier(preselectedBackend)\n                .then(function(savedStoreId) {\n                    if (!_.isEmpty(storeId) && !_.isEmpty(savedStoreId) && savedStoreId !== storeId) {\n                        logger.info(\n                            `Storage change detected (${savedStoreId} != ${storeId}) => volatiles data wipe out !`\n                        );\n                        shouldClear = true;\n                    }\n                    return shouldClear;\n                })\n                .then(function(clear) {\n                    if (clear) {\n                        return self.clearVolatileStores();\n                    }\n                    return false;\n                });\n        },\n\n        /**\n         * Clear the storages marked as volatile\n         * @returns {Promise<Boolean>} true if cleared\n         */\n        clearVolatileStores: function clearVolatileStores() {\n            var self = this;\n            var clearing = volatiles.map(function(storeName) {\n                return self.getStore(storeName).then(function(storeInstance) {\n                    return storeInstance.clear();\n                });\n            });\n\n            return Promise.all(clearing).then(function(results) {\n                return results && results.length === volatiles.length;\n            });\n        },\n\n        /**\n         * Observe changes on the given store\n         *\n         * @param {String} storeName - the name of the store to observe\n         * @returns {testStore} chains\n         */\n        startChangeTracking: function startChangeTracking(storeName) {\n            changeTracking[storeName] = false;\n            return this;\n        },\n\n        /**\n         * Has the store some changes\n         *\n         * @param {String} storeName - the name of the store to set as volatile\n         * @returns {Boolean} true if the given store has some changes\n         */\n        hasChanges: function hasChanges(storeName) {\n            return changeTracking[storeName] === true;\n        },\n\n        /**\n         * Reset the change listening\n         *\n         * @param {String} storeName - the name of the store\n         * @returns {testStore} chains\n         */\n        resetChanges: function resetChanges(storeName) {\n            if (_.isBoolean(changeTracking[storeName])) {\n                changeTracking[storeName] = false;\n            }\n            return this;\n        },\n\n        /**\n         * Remove the whole store\n         * @returns {Promise<Boolean>} true if done\n         */\n        remove: function remove() {\n            var legacyStoreExp = new RegExp(`-${testId}$`);\n            return isStoreModeUnified().then(function(isUnified) {\n                if (isUnified) {\n                    return store(testId, preselectedBackend).then(function(storeInstance) {\n                        return storeInstance.removeStore();\n                    });\n                }\n                return store.removeAll(function(storeName) {\n                    return legacyStoreExp.test(storeName);\n                }, preselectedBackend);\n            });\n        },\n\n        /**\n         * Wraps the identifier retrieval\n         * @returns {Promise<String>} the current store id\n         */\n        getStorageIdentifier: function getStorageIdentifier() {\n            return store.getIdentifier(preselectedBackend);\n        }\n    };\n}\n"],"names":["logger","loggerFactory","legacyPrefixes","modes","unified","fragmented","selectStoreMode","testId","preselectedBackend","store","getAll","validate","storeName","_","some","prefix","isEmpty","then","foundStores","isArray","length","testStoreLoader","storeNames","volatiles","changeTracking","testMode","isStoreModeUnified","isUndefined","result","debug","Promise","resolve","TypeError","getStore","trackChange","isBoolean","contains","push","isUnified","loadStore","loadedStore","keyPattern","RegExp","storeKey","key","getItem","getItems","entries","transform","acc","entry","test","replace","setItem","value","removeItem","clear","forEach","setVolatile","clearVolatileIfStoreChange","storeId","self","shouldClear","getIdentifier","savedStoreId","info","clearVolatileStores","clearing","map","storeInstance","all","results","startChangeTracking","hasChanges","resetChanges","remove","legacyStoreExp","removeStore","removeAll","getStorageIdentifier"],"mappings":"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"}