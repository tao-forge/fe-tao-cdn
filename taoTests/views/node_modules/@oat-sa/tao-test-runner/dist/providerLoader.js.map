{"version":3,"file":"providerLoader.js","sources":["../src/providerLoader.js"],"sourcesContent":["/**\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; under version 2\n * of the License (non-upgradable).\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * Copyright (c) 2019 Open Assessment Technologies SA ;\n */\n\n/**\n * Loads all the required providers and the underlying modules\n * required by the test runner.\n *\n *\n * @example\n * providerLoader({\n *    \"runner\": {\n *      \"id\": \"mock-runner\",\n *      \"module\": \"taoTests/test/runner/mocks/mockRunnerProvider\",\n *      \"bundle\": \"taoTests/test/runner/mocks/mockBundle.min\",\n *      \"category\": \"testrunner\"\n *    },\n *    \"proxy\": {\n *      \"id\": \"mock-proxy\",\n *      \"module\": \"taoTests/test/runner/mocks/mockProxyProvider\",\n *      \"bundle\": \"taoTests/test/runner/mocks/mockBundle.min\",\n *      \"category\": \"online\"\n *    },\n *    \"communicator\": {\n *      \"id\": \"request\",\n *      \"module\": \"core/communicator/request\",\n *      \"bundle\": \"loader/vendor.min\",\n *      \"category\": \"request\"\n *    },\n *    \"plugins\": [{\n *      \"id\": \"fooglin\",\n *      \"module\": \"taoTests/test/runner/mocks/mockPlugin1\",\n *      \"bundle\": \"taoTests/test/runner/mocks/mockBundle.min\",\n *      \"category\": \"content\"\n *    }, {\n *      \"id\": \"barglin\",\n *      \"module\": \"taoTests/test/runner/mocks/mockPlugin2\",\n *      \"bundle\": \"taoTests/test/runner/mocks/mockBundle.min\",\n *      \"category\": \"tools\"\n *    }]\n *  }, false)\n *  .then( ({ runnerProvider, plugins }) => {\n *      //...\n *  })\n *  .catch( err => console.error(err) );\n *\n *\n * @author Bertrand Chevrier <bertrand@taotesting.com>\n */\nimport loggerFactory from 'core/logger';\nimport providerLoader from 'core/providerLoader';\nimport pluginLoader from 'core/pluginLoader';\nimport communicator from 'core/communicator';\nimport runner from 'taoTests/runner/runner';\nimport proxy from 'taoTests/runner/proxy';\n\nconst logger = loggerFactory('taoTests/runner/loader');\n\n/**\n * @typedef {Object} provider - A provider is an object exposing a list of methods with respect to the API managed by the target.\n * @property {String} name - The name of the provider. It should be unique among all.\n * @property {Function} init - Each provider much expose at least a method `init()`\n * @property {Function} ... - Any other method the target is expecting\n */\n\n/**\n * Load the providers that match the registration\n * @param {Object} providers\n * @param {provider|provider[]} providers.runner\n * @param {provider|provider[]} [providers.proxy]\n * @param {provider|provider[]} [providers.communicator]\n * @param {provider|provider[]} [providers.plugins]\n * @param {Boolean} loadFromBundle - does the loader load the modules from the sources (dev mode) or the bundles\n * @returns {Promise<Object>} resolves with the loaded providers per provider type\n */\nexport default function loadTestRunnerProviders(providers = {}, loadFromBundle = false) {\n    /**\n     * Default way to load the modules and register the providers\n     * @param {Object[]} providersToLoad - the list of providers\n     * @param {Object} target - a provider target (an object that use the providers), it needs to expose registerProvider\n     * @returns {Promise<Object>} resolves with the target\n     * @throws {TypeError} if the target is not a provider target\n     */\n    const loadAndRegisterProvider = (providersToLoad = [], target) => {\n        if (!target || typeof target.registerProvider !== 'function') {\n            throw new TypeError('Trying to register providers on a target that is not a provider API');\n        }\n\n        return providerLoader()\n            .addList(providersToLoad)\n            .load(loadFromBundle)\n            .then(loadedProviders => {\n                loadedProviders.forEach(provider => target.registerProvider(provider.name, provider));\n                return target;\n            });\n    };\n\n    /**\n     * Available provider registration\n     */\n    const registration = {\n        runner(runnerProviders = []) {\n            return loadAndRegisterProvider(runnerProviders, runner);\n        },\n        communicator(communicatorProviders = []) {\n            return loadAndRegisterProvider(communicatorProviders, communicator);\n        },\n        proxy(proxyProviders = []) {\n            return loadAndRegisterProvider(proxyProviders, proxy);\n        },\n        plugins(plugins = []) {\n            return pluginLoader()\n                .addList(plugins)\n                .load(loadFromBundle);\n        }\n    };\n\n    if (!loadFromBundle) {\n        logger.warn('All modules will be loaded from sources');\n    }\n\n    return Promise.all(\n        Object.keys(providers).map(providerType => {\n            if (typeof registration[providerType] === 'function') {\n                logger.debug(`Start to load and register the '${providerType}' providers`);\n\n                const providersToLoad = Array.isArray(providers[providerType])\n                    ? providers[providerType]\n                    : [providers[providerType]];\n\n                return registration[providerType](providersToLoad).then(loaded => {\n                    logger.debug(`'${providerType}' providers are loaded and registered`);\n                    return { [providerType]: loaded };\n                });\n            } else {\n                logger.warn(`Ignoring the '${providerType}' providers loading, no registration method found`);\n            }\n        })\n    )\n        .then(results => results.reduce((acc, value) => Object.assign(acc, value), {}))\n        .catch(err => {\n            logger.error(`Error in test runner providers and plugins loading : ${err.message}`);\n\n            throw err;\n        });\n}\n"],"names":["logger","loggerFactory","loadTestRunnerProviders","providers","loadFromBundle","loadAndRegisterProvider","providersToLoad","target","registerProvider","TypeError","providerLoader","addList","load","then","loadedProviders","forEach","provider","name","registration","runner","runnerProviders","communicator","communicatorProviders","proxy","proxyProviders","plugins","pluginLoader","warn","Promise","all","Object","keys","map","providerType","debug","Array","isArray","loaded","results","reduce","acc","value","assign","catch","err","error","message"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;EAsEA,IAAMA,MAAM,GAAGC,aAAa,CAAC,wBAAD,CAA5B;EAEA;;;;;;;EAOA;;;;;;;;;;;AAUA,EAAe,SAASC,uBAAT,GAAyE;EAAA,MAAxCC,SAAwC,uEAA5B,EAA4B;EAAA,MAAxBC,cAAwB,uEAAP,KAAO;;EACpF;;;;;;;EAOA,MAAMC,uBAAuB,GAAG,SAA1BA,uBAA0B,GAAkC;EAAA,QAAjCC,eAAiC,uEAAf,EAAe;EAAA,QAAXC,MAAW;;EAC9D,QAAI,CAACA,MAAD,IAAW,OAAOA,MAAM,CAACC,gBAAd,KAAmC,UAAlD,EAA8D;EAC1D,YAAM,IAAIC,SAAJ,CAAc,qEAAd,CAAN;EACH;;EAED,WAAOC,cAAc,GAChBC,OADE,CACML,eADN,EAEFM,IAFE,CAEGR,cAFH,EAGFS,IAHE,CAGG,UAAAC,eAAe,EAAI;EACrBA,MAAAA,eAAe,CAACC,OAAhB,CAAwB,UAAAC,QAAQ;EAAA,eAAIT,MAAM,CAACC,gBAAP,CAAwBQ,QAAQ,CAACC,IAAjC,EAAuCD,QAAvC,CAAJ;EAAA,OAAhC;EACA,aAAOT,MAAP;EACH,KANE,CAAP;EAOH,GAZD;EAcA;;;;;EAGA,MAAMW,YAAY,GAAG;EACjBC,IAAAA,MADiB,oBACY;EAAA,UAAtBC,eAAsB,uEAAJ,EAAI;EACzB,aAAOf,uBAAuB,CAACe,eAAD,EAAkBD,OAAlB,CAA9B;EACH,KAHgB;EAIjBE,IAAAA,YAJiB,0BAIwB;EAAA,UAA5BC,qBAA4B,uEAAJ,EAAI;EACrC,aAAOjB,uBAAuB,CAACiB,qBAAD,EAAwBD,aAAxB,CAA9B;EACH,KANgB;EAOjBE,IAAAA,KAPiB,mBAOU;EAAA,UAArBC,cAAqB,uEAAJ,EAAI;EACvB,aAAOnB,uBAAuB,CAACmB,cAAD,EAAiBD,MAAjB,CAA9B;EACH,KATgB;EAUjBE,IAAAA,OAViB,qBAUK;EAAA,UAAdA,QAAc,uEAAJ,EAAI;;EAClB,aAAOC,YAAY,GACdf,OADE,CACMc,QADN,EAEFb,IAFE,CAEGR,cAFH,CAAP;EAGH;EAdgB,GAArB;;EAiBA,MAAI,CAACA,cAAL,EAAqB;EACjBJ,IAAAA,MAAM,CAAC2B,IAAP,CAAY,yCAAZ;EACH;;EAED,SAAOC,OAAO,CAACC,GAAR,CACHC,MAAM,CAACC,IAAP,CAAY5B,SAAZ,EAAuB6B,GAAvB,CAA2B,UAAAC,YAAY,EAAI;EACvC,QAAI,OAAOf,YAAY,CAACe,YAAD,CAAnB,KAAsC,UAA1C,EAAsD;EAClDjC,MAAAA,MAAM,CAACkC,KAAP,2CAAgDD,YAAhD;EAEA,UAAM3B,eAAe,GAAG6B,KAAK,CAACC,OAAN,CAAcjC,SAAS,CAAC8B,YAAD,CAAvB,IAClB9B,SAAS,CAAC8B,YAAD,CADS,GAElB,CAAC9B,SAAS,CAAC8B,YAAD,CAAV,CAFN;EAIA,aAAOf,YAAY,CAACe,YAAD,CAAZ,CAA2B3B,eAA3B,EAA4CO,IAA5C,CAAiD,UAAAwB,MAAM,EAAI;EAC9DrC,QAAAA,MAAM,CAACkC,KAAP,YAAiBD,YAAjB;EACA,mCAAUA,YAAV,EAAyBI,MAAzB;EACH,OAHM,CAAP;EAIH,KAXD,MAWO;EACHrC,MAAAA,MAAM,CAAC2B,IAAP,yBAA6BM,YAA7B;EACH;EACJ,GAfD,CADG,EAkBFpB,IAlBE,CAkBG,UAAAyB,OAAO;EAAA,WAAIA,OAAO,CAACC,MAAR,CAAe,UAACC,GAAD,EAAMC,KAAN;EAAA,aAAgBX,MAAM,CAACY,MAAP,CAAcF,GAAd,EAAmBC,KAAnB,CAAhB;EAAA,KAAf,EAA0D,EAA1D,CAAJ;EAAA,GAlBV,EAmBFE,KAnBE,CAmBI,UAAAC,GAAG,EAAI;EACV5C,IAAAA,MAAM,CAAC6C,KAAP,gEAAqED,GAAG,CAACE,OAAzE;EAEA,UAAMF,GAAN;EACH,GAvBE,CAAP;EAwBH;;;;;;;;"}