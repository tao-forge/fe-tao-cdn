define(['lodash', 'taoTests/runner/plugin', 'core/promiseQueue'], function (_, pluginFactory, promiseQueue) { 'use strict';

    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;
    pluginFactory = pluginFactory && Object.prototype.hasOwnProperty.call(pluginFactory, 'default') ? pluginFactory['default'] : pluginFactory;
    promiseQueue = promiseQueue && Object.prototype.hasOwnProperty.call(promiseQueue, 'default') ? promiseQueue['default'] : promiseQueue;

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2020 (original work) Open Assessment Technologies SA ;
     */
    /**
     * Creates the timer plugin
     */

    var duration = pluginFactory({
      name: 'duration',

      /**
       * Install step, add behavior before the lifecycle.
       */
      install: function install() {
        // define the "duration" store as "volatile" (removed on browser change).
        this.getTestRunner().getTestStore().setVolatile(this.getName());
      },

      /**
       * Initializes the plugin (called during runner's init)
       *
       * @returns {Promise}
       */
      init: function init() {
        var testRunner = this.getTestRunner();
        /**
         * A promise queue to ensure requests run sequentially
         */

        var queue = promiseQueue();
        var currentUpdatePromise = Promise.resolve(); //where the duration of attempts are stored

        return testRunner.getPluginStore(this.getName()).then(function (durationStore) {
          /**
           * Gets the duration of a particular item from the store
           *
           * @param {String} attemptId - the attempt id to get the duration for
           * @returns {Promise}
           */
          var getItemDuration = function getItemDuration(attemptId) {
            if (!/^(.*)+#+\d+$/.test(attemptId)) {
              return Promise.reject(new Error('Is it really an attempt id, like "itemid#attempt"'));
            }

            return durationStore.getItem(attemptId);
          };
          /**
           * Updates the duration of a particular item
           *
           * @param {Number} elapsed - time elapsed since previous tick
           * @returns {Promise}
           */


          var updateDuration = function updateDuration(elapsed) {
            var context = testRunner.getTestContext(); //store by attempt

            var itemAttemptId = "".concat(context.itemIdentifier, "#").concat(context.attempt);
            currentUpdatePromise = queue.serie(function () {
              return durationStore.getItem(itemAttemptId).then(function (duration) {
                duration = _.isNumber(duration) ? duration : 0;
                elapsed = _.isNumber(elapsed) && elapsed > 0 ? elapsed / 1000 : 0; //store the last duration

                return durationStore.setItem(itemAttemptId, duration + elapsed);
              });
            });
            return currentUpdatePromise;
          };

          var addDurationToCallActionParams = function addDurationToCallActionParams() {
            var context = testRunner.getTestContext();
            var itemAttemptId = "".concat(context.itemIdentifier, "#").concat(context.attempt);
            return getItemDuration(itemAttemptId).then(function (duration) {
              var params = {
                itemDuration: 0
              };

              if (_.isNumber(duration) && duration > 0) {
                params.itemDuration = duration;
              } // the duration will be sent to the server with the next request,
              // usually submitItem() or callItemAction()


              testRunner.getProxy().addCallActionParams(params);
            }).catch(_.noop);
          }; //change plugin state


          testRunner.on('tick', function (elapsed) {
            updateDuration(elapsed);
          }).after('move skip timeout', function () {
            return currentUpdatePromise.then(addDurationToCallActionParams).catch(addDurationToCallActionParams);
          }).before('pause exit', function () {
            return currentUpdatePromise.then(addDurationToCallActionParams).catch(addDurationToCallActionParams);
          })
          /**
           * @event duration.get
           * @param {String} attemptId - the attempt id to get the duration for
           * @param {getDuration} getDuration - a receiver callback
           */
          .on('plugin-get.duration', function (e, attemptId, getDuration) {
            if (_.isFunction(getDuration)) {
              getDuration(getItemDuration(attemptId));
            }
          });
        });
      }
    });

    return duration;

});
