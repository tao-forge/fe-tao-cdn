define(['exports', 'jquery', 'ui/keyNavigation/navigator', 'ui/keyNavigation/navigableDomElement', 'taoQtiTest/runner/plugins/content/accessibility/keyNavigation/helpers', 'lodash', 'taoQtiTest/runner/helpers/isReviewPanelEnabled', 'ui/scroller', 'i18n'], function (exports, $, keyNavigator, navigableDomElement, helpers, _, isReviewPanelEnabled, scrollHelper, __) { 'use strict';

    $ = $ && Object.prototype.hasOwnProperty.call($, 'default') ? $['default'] : $;
    keyNavigator = keyNavigator && Object.prototype.hasOwnProperty.call(keyNavigator, 'default') ? keyNavigator['default'] : keyNavigator;
    navigableDomElement = navigableDomElement && Object.prototype.hasOwnProperty.call(navigableDomElement, 'default') ? navigableDomElement['default'] : navigableDomElement;
    _ = _ && Object.prototype.hasOwnProperty.call(_, 'default') ? _['default'] : _;
    isReviewPanelEnabled = isReviewPanelEnabled && Object.prototype.hasOwnProperty.call(isReviewPanelEnabled, 'default') ? isReviewPanelEnabled['default'] : isReviewPanelEnabled;
    scrollHelper = scrollHelper && Object.prototype.hasOwnProperty.call(scrollHelper, 'default') ? scrollHelper['default'] : scrollHelper;
    __ = __ && Object.prototype.hasOwnProperty.call(__, 'default') ? __['default'] : __;

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2020 Open Assessment Technologies SA ;
     */
    /**
     * The identifier the keyNavigator group
     * @type {String}
     */

    var groupId = 'header-toolbar';
    /**
     * Key navigator strategy applying onto the header bar.
     * @type {Object} keyNavigationStrategy
     */

    var headerNavigation = {
      name: 'header',

      /**
       * Builds the header navigation strategy.
       *
       * @returns {keyNavigationStrategy}
       */
      init: function init() {
        var _this = this;

        var config = this.getConfig(); // we need a global selector as there is currently no way to access the delivery frame from the test runner

        var $headerBar = $('header');
        var $headerElements = $headerBar.find('a:visible');

        var registerHeaderNavigator = function registerHeaderNavigator(id, group, $elements) {
          var elements = navigableDomElement.createFromDoms($elements);

          if (elements.length) {
            var navigator = keyNavigator({
              id: id,
              group: group,
              elements: elements,
              propagateTab: false,
              defaultPosition: 0
            });
            helpers.setupItemsNavigator(navigator, config);
            helpers.setupClickableNavigator(navigator);

            _this.keyNavigators.push(navigator);
          }
        };

        this.keyNavigators = [];

        if (config.flatNavigation) {
          $headerElements.each(function (index, element) {
            return registerHeaderNavigator("".concat(groupId, "-").concat(index), $headerBar, $(element));
          });
        } else {
          registerHeaderNavigator(groupId, $headerBar, $headerElements);
        }

        return this;
      },

      /**
       * Gets the list of applied navigators
       * @returns {keyNavigator[]}
       */
      getNavigators: function getNavigators() {
        return this.keyNavigators;
      },

      /**
       * Tears down the keyNavigator strategy
       * @returns {keyNavigationStrategy}
       */
      destroy: function destroy() {
        this.keyNavigators.forEach(function (navigator) {
          return navigator.destroy();
        });
        this.keyNavigators = [];
        return this;
      }
    };

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2020 Open Assessment Technologies SA ;
     */
    /**
     * The identifier the keyNavigator group
     * @type {String}
     */

    var groupId$1 = 'bottom-toolbar';
    /**
     * Key navigator strategy applying onto the tools bar
     * @type {Object} keyNavigationStrategy
     */

    var toolbarNavigation = {
      name: 'toolbar',

      /**
       * Builds the toolbar navigation strategy.
       *
       * @returns {keyNavigationStrategy}
       */
      init: function init() {
        var _this = this;

        var config = this.getConfig();
        var $navigationBar = this.getTestRunner().getAreaBroker().getContainer().find('.bottom-action-bar');
        var $toolbarElements = $navigationBar.find('.action:not(.btn-group):visible, .action.btn-group .li-inner:visible');

        var registerToolbarNavigator = function registerToolbarNavigator(id, group, $elements) {
          var elements = navigableDomElement.createFromDoms($elements);

          if (elements.length) {
            var navigator = keyNavigator({
              id: id,
              group: group,
              elements: elements,
              propagateTab: false,
              defaultPosition: function defaultPosition(navigableElements) {
                var pos = 0; // search for the position of the "Next" button if any,
                // otherwise take the position of the last element

                if (config.autoFocus) {
                  pos = navigableElements.length - 1;

                  _.forEach(navigableElements, function (navigable, i) {
                    var $element = navigable.getElement();

                    if ($element.data('control') === 'move-forward' || $element.data('control') === 'move-end') {
                      pos = i;
                    }
                  });
                }

                return pos;
              }
            });
            helpers.setupItemsNavigator(navigator, config);
            helpers.setupClickableNavigator(navigator);

            _this.keyNavigators.push(navigator);
          }
        };

        this.keyNavigators = [];

        if (config.flatNavigation) {
          $toolbarElements.each(function (index, element) {
            return registerToolbarNavigator("".concat(groupId$1, "-").concat(index), $navigationBar, $(element));
          });
        } else {
          registerToolbarNavigator(groupId$1, $navigationBar, $toolbarElements);
        }

        return this;
      },

      /**
       * Gets the list of applied navigators
       * @returns {keyNavigator[]}
       */
      getNavigators: function getNavigators() {
        return this.keyNavigators;
      },

      /**
       * Tears down the keyNavigator strategy
       * @returns {keyNavigationStrategy}
       */
      destroy: function destroy() {
        this.keyNavigators.forEach(function (navigator) {
          return navigator.destroy();
        });
        this.keyNavigators = [];
        return this;
      }
    };

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2020 Open Assessment Technologies SA ;
     */
    /**
     * The identifier the keyNavigator group
     * @type {String}
     */

    var groupId$2 = 'top-toolbar';
    /**
     * Key navigator strategy applying onto the top toolbar' bar.
     * @type {Object} keyNavigationStrategy
     */

    var topToolbarNavigation = {
      name: 'top-toolbar',

      /**
       * Builds the top toolbar navigation strategy.
       *
       * @returns {keyNavigationStrategy}
       */
      init: function init() {
        var _this = this;

        var config = this.getConfig();
        var $topToolbar = this.getTestRunner().getAreaBroker().getContainer().find('.top-action-bar');
        var $toolbarElements = $topToolbar.find('.timer-toggler');

        var registerTopToolbarNavigator = function registerTopToolbarNavigator(id, group, $elements) {
          var elements = navigableDomElement.createFromDoms($elements);

          if (elements.length) {
            var navigator = keyNavigator({
              id: id,
              group: group,
              elements: elements,
              propagateTab: false
            });
            helpers.setupItemsNavigator(navigator, config);
            helpers.setupClickableNavigator(navigator);

            _this.keyNavigators.push(navigator);
          }
        };

        this.keyNavigators = [];
        $toolbarElements.each(function (index, element) {
          return registerTopToolbarNavigator("".concat(groupId$2, "-").concat(index), $topToolbar, $(element));
        });
        return this;
      },

      /**
       * Gets the list of applied navigators
       * @returns {keyNavigator[]}
       */
      getNavigators: function getNavigators() {
        return this.keyNavigators;
      },

      /**
       * Tears down the keyNavigator strategy
       * @returns {keyNavigationStrategy}
       */
      destroy: function destroy() {
        this.keyNavigators.forEach(function (navigator) {
          return navigator.destroy();
        });
        this.keyNavigators = [];
        return this;
      }
    };

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2020 Open Assessment Technologies SA ;
     */
    /**
     * List of CSS selectors for the navigables
     * @type {Object}
     */

    var selectors = {
      filters: '.qti-navigator-filters .qti-navigator-filter',
      unseenItems: '.qti-navigator-tree .qti-navigator-item:not(.unseen) .qti-navigator-label',
      allItems: '.qti-navigator-tree .qti-navigator-item .qti-navigator-label'
    };
    /**
     * Key navigator strategy applying onto the navigation panel.
     * @type {Object} keyNavigationStrategy
     */

    var navigatorNavigation = {
      name: 'navigator',

      /**
       * Builds the navigator navigation strategy.
       *
       * @returns {keyNavigationStrategy}
       */
      init: function init() {
        var config = this.getConfig();
        var $panel = this.getTestRunner().getAreaBroker().getPanelArea();
        var $navigator = $panel.find('.qti-navigator');
        var filtersNavigator;
        var itemsNavigator; //the tag to identify if the item listing has been browsed, to only "smart jump" to active item only on the first visit

        var itemListingVisited = false; //the position of the filter in memory, to only "smart jump" to active item only on the first visit

        var currentFilter;
        this.managedNavigators = [];
        this.keyNavigators = [];
        var testStatusNavigation;

        if ($navigator.length && !$navigator.hasClass('disabled')) {
          var $filters = $navigator.find(selectors.filters);
          var navigableFilters = navigableDomElement.createFromDoms($filters);
          var $testStatusHeader = $navigator.find('.qti-navigator-info.collapsible > .qti-navigator-label');
          var navigableTestStatus = navigableDomElement.createFromDoms($testStatusHeader);
          $testStatusHeader.addClass('key-navigation-actionable');

          if (navigableTestStatus.length) {
            testStatusNavigation = keyNavigator({
              keepState: config.keepState,
              id: 'navigator-test-status',
              propagateTab: false,
              elements: navigableTestStatus,
              group: $testStatusHeader
            });
            helpers.setupItemsNavigator(testStatusNavigation, {
              keyNextItem: config.keyNextTab || config.keyNextItem,
              keyPrevItem: config.keyPrevTab || config.keyPrevItem
            });
            this.keyNavigators.push(testStatusNavigation);
            this.managedNavigators.push(testStatusNavigation);
          }

          if (navigableFilters.length) {
            filtersNavigator = keyNavigator({
              keepState: config.keepState,
              id: 'navigator-filters',
              propagateTab: false,
              elements: navigableFilters,
              group: $navigator.find('.qti-navigator-filters')
            });
            helpers.setupItemsNavigator(filtersNavigator, {
              keyNextItem: config.keyNextTab || config.keyNextItem,
              keyPrevItem: config.keyPrevTab || config.keyPrevItem
            });
            helpers.setupClickableNavigator(filtersNavigator);

            if (config.keepState) {
              filtersNavigator.on('focus', function (cursor) {
                if (config.keepState) {
                  var $element = cursor.navigable.getElement();
                  var filter = $element.data('mode');
                  $element.click();

                  if (currentFilter !== filter) {
                    itemListingVisited = false;
                  }

                  currentFilter = filter;
                }
              });
            }

            if (config.keyNextContent) {
              filtersNavigator.on(config.keyNextContent, function (elem) {
                if (helpers.allowedToNavigateFrom(elem) && itemsNavigator) {
                  _.defer(function () {
                    if (itemListingVisited) {
                      itemsNavigator.first();
                    } else {
                      itemsNavigator.focus();
                    }
                  });
                }
              });
            }

            if (config.keyPrevContent) {
              filtersNavigator.on(config.keyPrevContent, function (elem) {
                if (helpers.allowedToNavigateFrom(elem) && itemsNavigator) {
                  _.defer(function () {
                    itemsNavigator.last();
                  });
                }
              });
            }

            this.keyNavigators.push(filtersNavigator);
            this.managedNavigators.push(filtersNavigator);
          }

          var $navigatorTree = $panel.find('.qti-navigator-tree');
          var skipAheadEnabled = $panel.find('.qti-navigator').is('.skipahead-enabled');
          var $trees = $navigator.find(skipAheadEnabled ? selectors.allItems : selectors.unseenItems);
          var navigableTrees = navigableDomElement.createFromDoms($trees);
          $trees.first().addClass('key-navigation-scrollable-up');
          $trees.last().addClass('key-navigation-scrollable-down');

          if (navigableTrees.length) {
            //instantiate a key navigator but do not add it to the returned list of navigators as this is not supposed to be reached with tab key
            itemsNavigator = keyNavigator({
              id: 'navigator-items',
              elements: navigableTrees,
              group: $navigatorTree,
              defaultPosition: function defaultPosition(navigableElements) {
                var pos = 0;

                if (config.flatNavigation || currentFilter !== 'flagged') {
                  pos = _.findIndex(navigableElements, function (navigable) {
                    var $parent = navigable.getElement().parent('.qti-navigator-item');

                    if ($parent.hasClass('active') && $parent.is(':visible')) {
                      return true;
                    }
                  });
                }

                return pos;
              }
            }).on('focus', function (cursor) {
              itemListingVisited = true;
              cursor.navigable.getElement().parent().addClass('key-navigation-highlight');
            }).on('blur', function (cursor) {
              cursor.navigable.getElement().parent().removeClass('key-navigation-highlight');
            });
            helpers.setupItemsNavigator(itemsNavigator, {
              keyNextItem: config.keyNextContent || config.keyNextItem,
              keyPrevItem: config.keyPrevContent || config.keyPrevItem
            });
            helpers.setupClickableNavigator(itemsNavigator);

            if (config.keepState) {
              itemsNavigator.on('lowerbound upperbound', function () {
                if (filtersNavigator) {
                  filtersNavigator.focus();
                }
              });
            }

            if (config.keyNextTab && config.keyPrevTab) {
              itemsNavigator.on(config.keyNextTab, function (elem) {
                if (helpers.allowedToNavigateFrom(elem) && filtersNavigator) {
                  filtersNavigator.focus().next();
                }
              });
              itemsNavigator.on(config.keyPrevTab, function (elem) {
                if (helpers.allowedToNavigateFrom(elem) && filtersNavigator) {
                  filtersNavigator.focus().previous();
                }
              });
            } else {
              this.keyNavigators.push(itemsNavigator);
            }

            this.managedNavigators.push(itemsNavigator);
          }
        }

        return this;
      },

      /**
       * Gets the list of applied navigators
       * @returns {keyNavigator[]}
       */
      getNavigators: function getNavigators() {
        return this.keyNavigators;
      },

      /**
       * Tears down the keyNavigator strategy
       * @returns {keyNavigationStrategy}
       */
      destroy: function destroy() {
        this.managedNavigators.forEach(function (navigator) {
          return navigator.destroy();
        });
        this.managedNavigators = [];
        this.keyNavigators = [];
        return this;
      }
    };

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2020 Open Assessment Technologies SA ;
     */
    /**
     * The identifier the keyNavigator group
     * @type {String}
     */

    var groupId$3 = 'item-content-wrapper';
    /**
     * Key navigator strategy applying onto the page.
     * @type {Object} keyNavigationStrategy
     */

    var pageNavigation = {
      name: 'page',

      /**
       * Builds the page navigation strategy.
       *
       * @returns {keyNavigationStrategy}
       */
      init: function init() {
        var _this = this;

        var config = this.getConfig();
        this.keyNavigators = [];
        this.getTestRunner().getAreaBroker().getContainer().find('.content-wrapper').addClass('key-navigation-scrollable').each(function (i, el) {
          var $element = $(el);
          var navigator = keyNavigator({
            id: "".concat(groupId$3, "-").concat(_this.keyNavigators.length),
            elements: navigableDomElement.createFromDoms($element),
            group: $element,
            propagateTab: false
          });
          helpers.setupItemsNavigator(navigator, config);

          _this.keyNavigators.push(navigator);
        });
        return this;
      },

      /**
       * Gets the list of applied navigators
       * @returns {keyNavigator[]}
       */
      getNavigators: function getNavigators() {
        return this.keyNavigators;
      },

      /**
       * Tears down the keyNavigator strategy
       * @returns {keyNavigationStrategy}
       */
      destroy: function destroy() {
        this.keyNavigators.forEach(function (navigator) {
          return navigator.destroy();
        });
        this.keyNavigators = [];
        return this;
      }
    };

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2020 Open Assessment Technologies SA ;
     */
    /**
     * The identifier the keyNavigator group
     * @type {String}
     */

    var groupId$4 = 'rubric-element-navigation-group';
    /**
     * Key navigator strategy applying onto the rubric blocks.
     * @type {Object} keyNavigationStrategy
     */

    var rubricsNavigation = {
      name: 'rubrics',

      /**
       * Builds the rubric blocks navigation strategy.
       *
       * @returns {keyNavigationStrategy}
       */
      init: function init() {
        var _this = this;

        var config = this.getConfig();
        this.keyNavigators = [];
        this.getTestRunner().getAreaBroker().getContainer().find('.qti-rubricBlock').addClass('key-navigation-scrollable').each(function (i, el) {
          var $element = $(el);
          var navigator = keyNavigator({
            id: "".concat(groupId$4, "-").concat(_this.keyNavigators.length),
            elements: navigableDomElement.createFromDoms($element),
            group: $element,
            propagateTab: false
          });
          helpers.setupItemsNavigator(navigator, config);

          _this.keyNavigators.push(navigator);
        });
        return this;
      },

      /**
       * Gets the list of applied navigators
       * @returns {keyNavigator[]}
       */
      getNavigators: function getNavigators() {
        return this.keyNavigators;
      },

      /**
       * Tears down the keyNavigator strategy
       * @returns {keyNavigationStrategy}
       */
      destroy: function destroy() {
        this.keyNavigators.forEach(function (navigator) {
          return navigator.destroy();
        });
        this.keyNavigators = [];
        return this;
      }
    };

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2020 Open Assessment Technologies SA ;
     */
    /**
     * Add aria-labelledby attribute to choice interaction
     *
     * @param {Navigator} cursor
     */

    var addLabelledByAttribute = function addLabelledByAttribute(cursor) {
      var $element = cursor.navigable.getElement();
      var value = $element.attr('value');
      var name = $element.attr('name');

      if (name) {
        $element.attr('aria-labelledby', "".concat(name.replace('response-', 'choice-'), "-").concat(value));
      }
    };
    /**
     * Add aria-labelledby attribute from choice interaction
     *
     * @param {Navigator} cursor
     */


    var removeLabelledByAttribute = function removeLabelledByAttribute(cursor) {
      var $element = cursor.navigable.getElement();
      $element.removeAttr('aria-labelledby', '');
    };
    /**
     * Adds attributes on navigation focus and blur
     * 
     * @param {Navigator} navigator 
     */


    var manageLabelledByAttribute = function manageLabelledByAttribute(navigator) {
      if (navigator) {
        navigator.on('focus', addLabelledByAttribute);
        navigator.on('blur', removeLabelledByAttribute); // applies WCAG behavior for the radio buttons
      }
    };
    /**
     * Key navigator strategy applying inside the item.
     * Navigable item content are interaction choices and body element with the special class "key-navigation-focusable".
     * @type {Object} keyNavigationStrategy
     */


    var itemNavigation = {
      name: 'item',

      /**
       * Builds the item navigation strategy.
       *
       * @returns {keyNavigationStrategy}
       */
      init: function init() {
        var _this = this;

        this.keyNavigators = [];
        var config = this.getConfig();
        var $content = this.getTestRunner().getAreaBroker().getContentArea();
        /**
         * Gets the QTI choice element from the current position in the keyNavigation
         * @param {Object} cursor - The cursor definition supplied by the keyNavigator
         * @returns {jQuery} - The selected choice element
         */

        var getQtiChoice = function getQtiChoice(cursor) {
          return cursor && cursor.navigable.getElement().closest('.qti-choice');
        };
        /**
         * Creates and registers a keyNavigator for the supplied list of elements
         * @param {jQuery} $elements - The list of navigable elements
         * @param {jQuery} group - The group container
         * @param {Boolean} [loop=false] - Allow cycling the list when a boundary is reached
         * @param {Number|Function} [defaultPosition=0] - The default position the group should set the focus on
         * @returns {keyNavigator} - the created navigator, if the list of element is not empty
         */


        var addNavigator = function addNavigator($elements, group) {
          var loop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var defaultPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          var elements = navigableDomElement.createFromDoms($elements);

          if (elements.length) {
            var navigator = keyNavigator({
              elements: elements,
              group: group,
              loop: loop,
              defaultPosition: defaultPosition,
              propagateTab: false
            });

            _this.keyNavigators.push(navigator);

            return navigator;
          }
        };
        /**
         * Creates and setups a keyNavigator for the interaction inputs.
         * @param {jQuery} $elements - The list of navigable elements
         * @param {jQuery} group - The group container
         * @param {Boolean} [loop=false] - Allow cycling the list when a boundary is reached
         * @param {Number|Function} [defaultPosition=0] - The default position the group should set the focus on
         * @returns {keyNavigator} - The supplied keyNavigator
         */


        var addInputsNavigator = function addInputsNavigator($elements, group, loop) {
          var defaultPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
          var navigator = addNavigator($elements, group, loop, defaultPosition);

          if (navigator) {
            helpers.setupItemsNavigator(navigator, config);
            helpers.setupClickableNavigator(navigator); // each choice is represented by more than the input, the style must be spread to the actual element

            navigator.on('focus', function (cursor) {
              return scrollHelper.scrollTo(getQtiChoice(cursor).addClass('key-navigation-highlight'), $content.closest('.content-wrapper'));
            }).on('blur', function (cursor) {
              return getQtiChoice(cursor).removeClass('key-navigation-highlight');
            });
          }

          return navigator;
        }; // list the navigable areas inside the item. This could be either the interactions choices or the prompts


        var $qtiInteractions = $content.find('.key-navigation-focusable,.qti-interaction') //filter out interaction as it will be managed separately
        .filter(function (i, node) {
          return !$(node).parents('.qti-interaction').length;
        }); // the item focusable body elements are considered scrollable

        $content.find('.key-navigation-focusable').addClass('key-navigation-scrollable'); // each navigable area will get its own keyNavigator

        $qtiInteractions.each(function (itemPos, itemElement) {
          var $itemElement = $(itemElement); // detect the type of choices: checkbox or radio

          var $choiceInput = $itemElement.find('.qti-choice input');
          var choiceType = $choiceInput.attr('type');

          if ($itemElement.hasClass('qti-interaction')) {
            //add navigable elements from prompt
            $itemElement.find('.key-navigation-focusable').each(function (navPos, nav) {
              var $nav = $(nav);

              if (!$nav.closest('.qti-choice').length) {
                addNavigator($nav, $nav);
              }
            }); //reset interaction custom key navigation to override the behaviour with the new one

            $itemElement.off('.keyNavigation'); //search for inputs that represent the interaction focusable choices

            var $inputs = $itemElement.is(':input') ? $itemElement : $itemElement.find(':input');

            if (config.flatNavigation && choiceType !== 'radio') {
              $inputs.each(function (i, input) {
                var navigator = addInputsNavigator($(input), $itemElement);
                manageLabelledByAttribute(navigator);
              });
            } else {
              var navigator = addInputsNavigator($inputs, $itemElement, true, function () {
                // keep default positioning for now
                var position = -1; // autofocus the selected radio button if any

                $inputs.each(function (index, input) {
                  if (input.checked) {
                    position = index;
                  }
                });
                return position;
              });
              manageLabelledByAttribute(navigator); // applies WCAG behavior for the radio buttons

              if (navigator && config.wcagBehavior) {
                navigator.on('focus', function (cursor) {
                  var $element = cursor.navigable.getElement();

                  if (!$element.is(':checked')) {
                    $element.click();
                  }
                });
              }
            }
          } else {
            addNavigator($itemElement, $itemElement);
          }
        });
        return this;
      },

      /**
       * Gets the list of applied navigators
       * @returns {keyNavigator[]}
       */
      getNavigators: function getNavigators() {
        return this.keyNavigators;
      },

      /**
       * Tears down the keyNavigator strategy
       * @returns {keyNavigationStrategy}
       */
      destroy: function destroy() {
        this.keyNavigators.forEach(function (navigator) {
          return navigator.destroy();
        });
        this.keyNavigators = [];
        return this;
      }
    };

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2020 Open Assessment Technologies SA ;
     */
    /**
     * Key navigator strategy applying inside the item.
     * Navigable item content are interaction choices with the special class "key-navigation-focusable".
     * @type {Object} keyNavigationStrategy
     */

    var linearItemNavigation = {
      name: 'linearItem',

      /**
       * Builds the item navigation strategy.
       *
       * @returns {keyNavigationStrategy}
       */
      init: function init() {
        var _this = this;

        var config = this.getConfig();
        var $content = this.getTestRunner().getAreaBroker().getContentArea();
        var $qtiInteractions = $content.find('.key-navigation-focusable,.qti-interaction') //filter out interaction as it will be managed separately
        .filter(function (i, node) {
          return !$(node).parents('.qti-interaction').length;
        });
        var $qtiChoices = $qtiInteractions.find('.qti-choice');
        var $lastParent = null;
        var list = [];

        var setupListNavigator = function setupListNavigator() {
          var navigator = keyNavigator({
            elements: list,
            propagateTab: false
          });
          helpers.setupItemsNavigator(navigator, config);

          _this.choicesNavigators.push(navigator);
        }; // this strategy manages 2 navigators:
        // - keyNavigators lists all elements separately, allowing to navigate among them as identified groups
        // - choicesNavigators lists elements with the same parent, allowing to navigate "horizontally" among them


        this.keyNavigators = [];
        this.choicesNavigators = []; // the item focusable body elements are considered scrollable

        $content.find('.key-navigation-focusable').addClass('key-navigation-scrollable');
        $qtiChoices.each(function (i, el) {
          var $itemElement = $(el);
          var $parent = $itemElement.parent();
          var choiceNavigator = keyNavigator({
            elements: navigableDomElement.createFromDoms($itemElement),
            group: $itemElement,
            propagateTab: false
          });
          helpers.setupClickableNavigator(choiceNavigator);

          if ($lastParent && !$parent.is($lastParent)) {
            setupListNavigator();
            list = [];
          }

          _this.keyNavigators.push(choiceNavigator);

          list.push(choiceNavigator);
          $lastParent = $parent;
        });

        if (list.length) {
          setupListNavigator();
          list = [];
        }

        return this;
      },

      /**
       * Gets the list of applied navigators
       * @returns {keyNavigator[]}
       */
      getNavigators: function getNavigators() {
        return this.keyNavigators;
      },

      /**
       * Tears down the keyNavigator strategy
       * @returns {keyNavigationStrategy}
       */
      destroy: function destroy() {
        this.keyNavigators.forEach(function (navigator) {
          return navigator.destroy();
        });
        this.choicesNavigators.forEach(function (navigator) {
          return navigator.destroy();
        });
        this.choicesNavigators = [];
        this.keyNavigators = [];
        return this;
      }
    };

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2020 Open Assessment Technologies SA ;
     */
    /**
    * The identifier the keyNavigator group
    * @type {String}
    */

    var groupId$5 = 'stimulus-element-navigation-group';
    /**
     * Key navigator strategy applying on stimulus items with scrollbar.
     * Navigable item content are body elements with the special class "stimulus-container".
     * @type {Object} keyNavigationStrategy
     */

    var stimulusNavigation = {
      name: 'stimulus',

      /**
       * Builds the item navigation strategy.
       *
       * @returns {keyNavigationStrategy}
       */
      init: function init() {
        var _this = this;

        var config = this.getConfig();
        var $content = this.getTestRunner().getAreaBroker().getContentArea();
        this.keyNavigators = []; // decorate isEnabled navigableDomElement method to check for dom node height

        var isEnabledDecorator = function isEnabledDecorator(element) {
          var originalIsEnabled = element.isEnabled;

          element.isEnabled = function isEnabled() {
            if (originalIsEnabled.call(this)) {
              var node = this.getElement().get(0);
              return node.scrollHeight > node.clientHeight;
            }

            return false;
          };

          return element;
        };

        $content.find('.stimulus-container').addClass('key-navigation-scrollable').each(function (i, el) {
          var $element = $(el);
          var elements = navigableDomElement.createFromDoms($element).map(isEnabledDecorator); // assign aria attributes

          $element.attr('aria-label', __('Passage'));
          var navigator = keyNavigator({
            id: "".concat(groupId$5, "-").concat(i),
            elements: elements,
            group: $element,
            propagateTab: false
          });
          helpers.setupItemsNavigator(navigator, config);

          _this.keyNavigators.push(navigator);
        });
        return this;
      },

      /**
       * Gets the list of applied navigators
       * @returns {keyNavigator[]}
       */
      getNavigators: function getNavigators() {
        return this.keyNavigators;
      },

      /**
       * Tears down the keyNavigator strategy
       * @returns {keyNavigationStrategy}
       */
      destroy: function destroy() {
        this.keyNavigators.forEach(function (navigator) {
          return navigator.destroy();
        });
        this.keyNavigators = [];
        return this;
      }
    };

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2020 Open Assessment Technologies SA ;
     */
    /**
     * The identifier the keyNavigator group
     * @type {String}
     */

    var groupId$6 = 'jump-links';
    /**
     * Key navigator strategy applying onto the top toolbar' bar.
     * @type {Object} keyNavigationStrategy
     */

    var jumpLinks = {
      name: 'jump-links',

      /**
       * Builds the top toolbar navigation strategy.
       *
       * @returns {keyNavigationStrategy}
       */
      init: function init() {
        var _this = this;

        var config = this.getConfig();
        var $jumpLinksBox = $('.content-wrap');
        var $links = $jumpLinksBox.find('.jump-link');
        this.keyNavigators = [];

        var registerTopToolbarNavigator = function registerTopToolbarNavigator(id, group, $elements) {
          var elements = navigableDomElement.createFromDoms($elements);

          if (elements.length) {
            var navigator = keyNavigator({
              id: id,
              group: group,
              elements: elements,
              propagateTab: false
            });
            helpers.setupItemsNavigator(navigator, config);
            helpers.setupClickableNavigator(navigator);

            _this.keyNavigators.push(navigator);
          }
        };

        $links.each(function (index, element) {
          return registerTopToolbarNavigator("".concat(groupId$6, "-").concat(index), $jumpLinksBox, $(element));
        });
        return this;
      },

      /**
       * Gets the list of applied navigators
       * @returns {keyNavigator[]}
       */
      getNavigators: function getNavigators() {
        return this.keyNavigators;
      },

      /**
       * Tears down the keyNavigator strategy
       * @returns {keyNavigationStrategy}
       */
      destroy: function destroy() {
        this.keyNavigators.forEach(function (navigator) {
          return navigator.destroy();
        });
        this.keyNavigators = [];
        return this;
      }
    };

    exports.headerNavigationStrategy = headerNavigation;
    exports.itemNavigationStrategy = itemNavigation;
    exports.jumpLinksNavigationStrategy = jumpLinks;
    exports.linearItemNavigationStrategy = linearItemNavigation;
    exports.navigatorNavigationStrategy = navigatorNavigation;
    exports.pageNavigationStrategy = pageNavigation;
    exports.rubricsNavigationStrategy = rubricsNavigation;
    exports.stimulusNavigationStrategy = stimulusNavigation;
    exports.toolbarNavigationStrategy = toolbarNavigation;
    exports.topToolbarNavigationStrategy = topToolbarNavigation;

    Object.defineProperty(exports, '__esModule', { value: true });

});
