{"version":3,"file":"probeOverseer.js","sources":["../src/probeOverseer.js"],"sourcesContent":["/*\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; under version 2\n * of the License (non-upgradable).\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * Copyright (c) 2016-2019 (original work) Open Assessment Technlogies SA\n *\n */\n\n/**\n * The probeOverseer let's you define probes that will listen for events and record logs\n *\n * @author Bertrand Chevrier <bertrand@taotesting.com>\n */\nimport _ from 'lodash';\nimport moment from 'moment';\nimport uuid from 'lib/uuid';\nimport 'lib/moment-timezone.min';\n\nvar timeZone = moment.tz.guess();\n\nvar slice = Array.prototype.slice;\n\n/**\n * Create the overseer intance\n * @param {runner} runner - a instance of a test runner\n * @returns {probeOverseer} the new probe overseer\n * @throws TypeError if something goes wrong\n */\nexport default function probeOverseerFactory(runner) {\n    // the created instance\n    var overseer;\n\n    // the list of registered probes\n    var probes = [];\n\n    //temp queue\n    var queue = [];\n\n    //immutable queue which will not be flushed\n    var immutableQueue = [];\n\n    /**\n     * @type {Storage} to store the collected events\n     */\n    var queueStorage;\n\n    /**\n     * @type {Promise} Promises chain to avoid write collisions\n     */\n    var writing = Promise.resolve();\n\n    //is the overseer started\n    var started = false;\n\n    /**\n     * Get the storage instance\n     * @returns {Promise} that resolves with the storage\n     */\n    var getStorage = function getStorage() {\n        if (queueStorage) {\n            return Promise.resolve(queueStorage);\n        }\n        return runner\n            .getTestStore()\n            .getStore('test-probe')\n            .then(function(newStorage) {\n                queueStorage = newStorage;\n                return Promise.resolve(queueStorage);\n            });\n    };\n\n    /**\n     * Unset the storage instance\n     */\n    var resetStorage = function resetStorage() {\n        queueStorage = null;\n    };\n\n    /**\n     * Register the collection event of a probe against a runner\n     * @param {Object} probe - a valid probe\n     */\n    function collectEvent(probe) {\n        var eventNs = `.probe-${probe.name}`;\n\n        //event handler registered to collect data\n        var probeHandler = function probeHandler() {\n            var now = moment();\n            var data = {\n                id: uuid(12, 16),\n                type: probe.name,\n                timestamp: now.format('x') / 1000,\n                timezone: now.tz(timeZone).format('Z')\n            };\n            if (typeof probe.capture === 'function') {\n                data.context = probe.capture.apply(probe, [runner].concat(slice.call(arguments)));\n            }\n            overseer.push(data);\n        };\n\n        //fallback\n        if (probe.latency) {\n            return collectLatencyEvent(probe);\n        }\n\n        _.forEach(probe.events, function(eventName) {\n            var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n            runner.on(listen, _.partial(probeHandler, eventName));\n        });\n    }\n\n    function collectLatencyEvent(probe) {\n        var eventNs = `.probe-${probe.name}`;\n\n        //start event handler registered to collect data\n        var startHandler = function startHandler() {\n            var now = moment();\n            var data = {\n                id: uuid(12, 16),\n                marker: 'start',\n                type: probe.name,\n                timestamp: now.format('x') / 1000,\n                timezone: now.tz(timeZone).format('Z')\n            };\n\n            if (typeof probe.capture === 'function') {\n                data.context = probe.capture.apply(probe, [runner].concat(slice.call(arguments)));\n            }\n            overseer.push(data);\n        };\n\n        //stop event handler registered to collect data\n        var stopHandler = function stopHandler() {\n            var now = moment();\n            var last;\n            var data = {\n                type: probe.name,\n                timestamp: now.format('x') / 1000,\n                timezone: now.tz(timeZone).format('Z')\n            };\n            var args = slice.call(arguments);\n\n            last = _.findLast(immutableQueue, { type: probe.name, marker: 'start' });\n            if (last && !_.findLast(immutableQueue, { type: probe.name, marker: 'end', id: last.id })) {\n                data.id = last.id;\n                data.marker = 'end';\n                if (typeof probe.capture === 'function') {\n                    data.context = probe.capture.apply(probe, [runner].concat(args));\n                }\n                overseer.push(data);\n            }\n        };\n\n        //fallback\n        if (!probe.latency) {\n            return collectEvent(probe);\n        }\n\n        _.forEach(probe.startEvents, function(eventName) {\n            var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n            runner.on(listen, _.partial(startHandler, eventName));\n        });\n        _.forEach(probe.stopEvents, function(eventName) {\n            var listen = eventName.indexOf('.') > 0 ? eventName : eventName + eventNs;\n            runner.on(listen, _.partial(stopHandler, eventName));\n        });\n    }\n\n    //argument validation\n    if (!_.isPlainObject(runner) || !_.isFunction(runner.init) || !_.isFunction(runner.on)) {\n        throw new TypeError('Please set a test runner');\n    }\n\n    /**\n     * @typedef {probeOverseer}\n     */\n    overseer = {\n        /**\n         * Add a new probe\n         * @param {Object} probe\n         * @param {String} probe.name - the probe name\n         * @param {Boolean} [probe.latency = false] - simple or latency mode\n         * @param {String[]} [probe.events] - the list of events to listen (simple mode)\n         * @param {String[]} [probe.startEvents] - the list of events to mark the start (lantency mode)\n         * @param {String[]} [probe.stopEvents] - the list of events to mark the end (latency mode)\n         * @param {Function} [probe.capture] - lambda fn to define the data context, it receive the test runner and the event parameters\n         * @returns {probeOverseer} chains\n         * @throws TypeError if the probe is not well formatted\n         */\n        add: function add(probe) {\n            // probe structure strict validation\n\n            if (!_.isPlainObject(probe)) {\n                throw new TypeError('A probe is a plain object');\n            }\n            if (!_.isString(probe.name) || _.isEmpty(probe.name)) {\n                throw new TypeError('A probe must have a name');\n            }\n            if (_.where(probes, { name: probe.name }).length > 0) {\n                throw new TypeError('A probe with this name is already regsitered');\n            }\n\n            if (probe.latency) {\n                if (_.isString(probe.startEvents) && !_.isEmpty(probe.startEvents)) {\n                    probe.startEvents = [probe.startEvents];\n                }\n                if (_.isString(probe.stopEvents) && !_.isEmpty(probe.stopEvents)) {\n                    probe.stopEvents = [probe.stopEvents];\n                }\n                if (!probe.startEvents.length || !probe.stopEvents.length) {\n                    throw new TypeError('Latency based probes must have startEvents and stopEvents defined');\n                }\n\n                //if already started we register the events on addition\n                if (started) {\n                    collectLatencyEvent(probe);\n                }\n            } else {\n                if (_.isString(probe.events) && !_.isEmpty(probe.events)) {\n                    probe.events = [probe.events];\n                }\n                if (!_.isArray(probe.events) || probe.events.length === 0) {\n                    throw new TypeError('A probe must define events');\n                }\n\n                //if already started we register the events on addition\n                if (started) {\n                    collectEvent(probe);\n                }\n            }\n\n            probes.push(probe);\n\n            return this;\n        },\n\n        /**\n         * Get the time entries queue\n         * @returns {Promise} with the data in parameterj\n         */\n        getQueue: function getQueue() {\n            return getStorage().then(function(storage) {\n                return storage.getItem('queue');\n            });\n        },\n\n        /**\n         * Get the list of defined probes\n         * @returns {Object[]} the probes collection\n         */\n        getProbes: function getProbes() {\n            return probes;\n        },\n\n        /**\n         * Push a time entry to the queue\n         * @param {Object} entry - the time entry\n         */\n        push: function push(entry) {\n            getStorage().then(function(storage) {\n                //ensure the queue is pushed to the store consistently and atomically\n                writing = writing.then(function() {\n                    queue.push(entry);\n                    immutableQueue.push(entry);\n                    return storage.setItem('queue', queue);\n                });\n            });\n        },\n\n        /**\n         * Flush the queue and get the entries\n         * @returns {Promise} with the data in parameter\n         */\n        flush: function flush() {\n            return new Promise(function(resolve) {\n                getStorage().then(function(storage) {\n                    writing = writing.then(function() {\n                        return storage.getItem('queue').then(function(flushed) {\n                            queue = [];\n                            return storage.setItem('queue', queue).then(function() {\n                                resolve(flushed);\n                            });\n                        });\n                    });\n                });\n            });\n        },\n\n        /**\n         * Start the probes\n         * @returns {Promise} once started\n         */\n        start: function start() {\n            return getStorage().then(function(storage) {\n                return storage.getItem('queue').then(function(savedQueue) {\n                    if (_.isArray(savedQueue)) {\n                        queue = savedQueue;\n                        immutableQueue = savedQueue;\n                    }\n                    _.forEach(probes, collectEvent);\n                    started = true;\n                });\n            });\n        },\n\n        /**\n         * Stop the probes\n         * Be carefull, stop will also clear the store and the queue\n         * @returns {Promise} once stopped\n         */\n        stop: function stop() {\n            started = false;\n            _.forEach(probes, function(probe) {\n                var eventNs = `.probe-${probe.name}`;\n                var removeHandler = function removeHandler(eventName) {\n                    runner.off(eventName + eventNs);\n                };\n\n                _.forEach(probe.startEvents, removeHandler);\n                _.forEach(probe.stopEvents, removeHandler);\n                _.forEach(probe.events, removeHandler);\n            });\n\n            queue = [];\n            immutableQueue = [];\n            return getStorage().then(function(storage) {\n                return storage.removeItem('queue').then(resetStorage);\n            });\n        }\n    };\n    return overseer;\n}\n"],"names":["timeZone","moment","tz","guess","slice","Array","prototype","probeOverseerFactory","runner","overseer","probes","queue","immutableQueue","queueStorage","writing","Promise","resolve","started","getStorage","getTestStore","getStore","then","newStorage","resetStorage","collectEvent","probe","eventNs","name","probeHandler","now","data","id","uuid","type","timestamp","format","timezone","capture","context","apply","concat","call","arguments","push","latency","collectLatencyEvent","_","forEach","events","eventName","listen","indexOf","on","partial","startHandler","marker","stopHandler","last","args","findLast","startEvents","stopEvents","isPlainObject","isFunction","init","TypeError","add","isString","isEmpty","where","length","isArray","getQueue","storage","getItem","getProbes","entry","setItem","flush","flushed","start","savedQueue","stop","removeHandler","off","removeItem"],"mappings":"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"}