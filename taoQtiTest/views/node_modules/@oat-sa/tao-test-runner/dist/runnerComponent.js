define(['lodash', 'ui/component', 'taoTests/runner/runner', 'taoTests/runner/providerLoader', 'handlebars'], function (_, component, runnerFactory, providerLoader, Handlebars) { 'use strict';

  _ = _ && _.hasOwnProperty('default') ? _['default'] : _;
  component = component && component.hasOwnProperty('default') ? component['default'] : component;
  runnerFactory = runnerFactory && runnerFactory.hasOwnProperty('default') ? runnerFactory['default'] : runnerFactory;
  providerLoader = providerLoader && providerLoader.hasOwnProperty('default') ? providerLoader['default'] : providerLoader;
  Handlebars = Handlebars && Handlebars.hasOwnProperty('default') ? Handlebars['default'] : Handlebars;

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  var Template = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
    this.compilerInfo = [4,'>= 1.0.0'];
  helpers = this.merge(helpers, Handlebars.helpers);  


    return "<div class=\"runner-component\"></div>\n";
    });
  function runnerComponentTpl(data, options, asString) {
    var html = Template(data, options);
    return (asString || true) ? html : $(html);
  }

  /**
   * Validate required options from the configuration
   * @param {Object} config
   * @returns {Boolean} true if valid
   * @throws {TypeError} in case of validation failure
   */

  function validateTestRunnerConfiguration() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var requiredProperties = ['providers', 'options', 'serviceCallId'];

    if (_typeof(config) !== 'object') {
      throw new TypeError("The runner configuration must be an object, '".concat(_typeof(config), "' received"));
    }

    if (requiredProperties.some(function (property) {
      return typeof config[property] === 'undefined';
    })) {
      throw new TypeError("The runner configuration must contains at least the following properties : ".concat(requiredProperties.join(',')));
    }

    return true;
  }
  /**
   * Get the selected provider if set or infer it from the providers list
   * @param {String} type - the type of provider (runner, communicator, proxy, etc.)
   * @param {Object} config
   * @returns {String} the selected provider for the given type
   */


  function getSelectedProvider() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'runner';
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (config.provider && config.provider[type]) {
      return config.provider[type];
    }

    if (config.providers && config.providers[type]) {
      var typeProviders = config.providers[type];

      if (_typeof(typeProviders) === 'object' && (typeProviders.id || typeProviders.name)) {
        return typeProviders.id || typeProviders.name;
      }

      if (Array.isArray(typeProviders) && typeProviders.length > 0) {
        return typeProviders[0].id || typeProviders[0].name;
      }
    }

    return false;
  }
  /**
   * Wraps a test runner into a component
   * @param {jQuery|HTMLElement|String} container - The container in which renders the component
   * @param {Object} config - The component configuration options
   * @param {String} config.serviceCallId - The identifier of the test session
   * @param {Object} config.providers
   * @param {Object} config.options
   * @param {Boolean} [config.loadFromBundle=false] - do we load the modules from the bundles
   * @param {Boolean} [config.replace] - When the component is appended to its container, clears the place before
   * @param {Number|String} [config.width] - The width in pixels, or 'auto' to use the container's width
   * @param {Number|String} [config.height] - The height in pixels, or 'auto' to use the container's height
   * @param {Function} [template] - An optional template for the component
   * @returns {runnerComponent}
   */


  function runnerComponentFactory() {
    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var template = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : runnerComponentTpl;
    var runner = null;
    var plugins = [];

    if (!container) {
      throw new TypeError('A container element must be defined to contain the runnerComponent');
    }

    validateTestRunnerConfiguration(config);
    /**
     * @typedef {runner} runnerComponent
     */

    var runnerComponent = component({
      /**
       * Gets the option's value
       * @param {String} name - the option key
       * @returns {*}
       */
      getOption: function getOption(name) {
        return this.config.options[name];
      },

      /**
       * Gets the test runner
       * @returns {runner}
       */
      getRunner: function getRunner() {
        return runner;
      }
    }).setTemplate(template).on('init', function () {
      var _this = this;

      //load the defined providers for the runner, the proxy, the communicator, the plugins, etc.
      return providerLoader(config.providers, config.loadFromBundle).then(function (results) {
        if (results && results.plugins) {
          plugins = results.plugins;
        }

        _this.render(container);

        _this.hide();
      }).catch(function (err) {
        return _this.trigger('error', err);
      });
    }).on('render', function () {
      var _this2 = this;

      var runnerConfig = Object.assign(_.omit(this.config, ['providers']), {
        renderTo: this.getElement()
      });
      runnerConfig.provider = Object.keys(this.config.providers).reduce(function (acc, providerType) {
        if (!acc[providerType] && providerType !== 'plugins') {
          acc[providerType] = getSelectedProvider(providerType, _this2.config);
        }

        return acc;
      }, runnerConfig.provider || {});
      runner = runnerFactory(runnerConfig.provider.runner, plugins, runnerConfig).on('ready', function () {
        _.defer(function () {
          _this2.setState('ready').trigger('ready', runner).show();
        });
      }).on('destroy', function () {
        return runner = null;
      }).spread(this, 'error').init();
    }).on('destroy', function () {
      var destroying = runner && runner.destroy();
      runner = null;
      return destroying;
    }).after('destroy', function () {
      this.removeAllListeners();
    });
    return runnerComponent.init(config);
  }

  return runnerComponentFactory;

});
