define(['core/logger', 'core/providerLoader', 'core/pluginLoader', 'core/communicator', 'taoTests/runner/runner', 'taoTests/runner/proxy'], function (loggerFactory, providerLoader, pluginLoader, _communicator, _runner, _proxy) { 'use strict';

  loggerFactory = loggerFactory && loggerFactory.hasOwnProperty('default') ? loggerFactory['default'] : loggerFactory;
  providerLoader = providerLoader && providerLoader.hasOwnProperty('default') ? providerLoader['default'] : providerLoader;
  pluginLoader = pluginLoader && pluginLoader.hasOwnProperty('default') ? pluginLoader['default'] : pluginLoader;
  _communicator = _communicator && _communicator.hasOwnProperty('default') ? _communicator['default'] : _communicator;
  _runner = _runner && _runner.hasOwnProperty('default') ? _runner['default'] : _runner;
  _proxy = _proxy && _proxy.hasOwnProperty('default') ? _proxy['default'] : _proxy;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var logger = loggerFactory('taoTests/runner/loader');
  /**
   * @typedef {Object} provider - A provider is an object exposing a list of methods with respect to the API managed by the target.
   * @property {String} name - The name of the provider. It should be unique among all.
   * @property {Function} init - Each provider much expose at least a method `init()`
   * @property {Function} ... - Any other method the target is expecting
   */

  /**
   * Load the providers that match the registration
   * @param {Object} providers
   * @param {provider|provider[]} providers.runner
   * @param {provider|provider[]} [providers.proxy]
   * @param {provider|provider[]} [providers.communicator]
   * @param {provider|provider[]} [providers.plugins]
   * @param {Boolean} loadFromBundle - does the loader load the modules from the sources (dev mode) or the bundles
   * @returns {Promise<Object>} resolves with the loaded providers per provider type
   */

  function loadTestRunnerProviders() {
    var providers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var loadFromBundle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    /**
     * Default way to load the modules and register the providers
     * @param {Object[]} providersToLoad - the list of providers
     * @param {Object} target - a provider target (an object that use the providers), it needs to expose registerProvider
     * @returns {Promise<Object>} resolves with the target
     * @throws {TypeError} if the target is not a provider target
     */
    var loadAndRegisterProvider = function loadAndRegisterProvider() {
      var providersToLoad = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var target = arguments.length > 1 ? arguments[1] : undefined;

      if (!target || typeof target.registerProvider !== 'function') {
        throw new TypeError('Trying to register providers on a target that is not a provider API');
      }

      return providerLoader().addList(providersToLoad).load(loadFromBundle).then(function (loadedProviders) {
        loadedProviders.forEach(function (provider) {
          return target.registerProvider(provider.name, provider);
        });
        return target;
      });
    };
    /**
     * Available provider registration
     */


    var registration = {
      runner: function runner() {
        var runnerProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return loadAndRegisterProvider(runnerProviders, _runner);
      },
      communicator: function communicator() {
        var communicatorProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return loadAndRegisterProvider(communicatorProviders, _communicator);
      },
      proxy: function proxy() {
        var proxyProviders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return loadAndRegisterProvider(proxyProviders, _proxy);
      },
      plugins: function plugins() {
        var _plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        return pluginLoader().addList(_plugins).load(loadFromBundle);
      }
    };

    if (!loadFromBundle) {
      logger.warn('All modules will be loaded from sources');
    }

    return Promise.all(Object.keys(providers).map(function (providerType) {
      if (typeof registration[providerType] === 'function') {
        logger.debug("Start to load and register the '".concat(providerType, "' providers"));
        var providersToLoad = Array.isArray(providers[providerType]) ? providers[providerType] : [providers[providerType]];
        return registration[providerType](providersToLoad).then(function (loaded) {
          logger.debug("'".concat(providerType, "' providers are loaded and registered"));
          return _defineProperty({}, providerType, loaded);
        });
      } else {
        logger.warn("Ignoring the '".concat(providerType, "' providers loading, no registration method found"));
      }
    })).then(function (results) {
      return results.reduce(function (acc, value) {
        return Object.assign(acc, value);
      }, {});
    }).catch(function (err) {
      logger.error("Error in test runner providers and plugins loading : ".concat(err.message));
      throw err;
    });
  }

  return loadTestRunnerProviders;

});
