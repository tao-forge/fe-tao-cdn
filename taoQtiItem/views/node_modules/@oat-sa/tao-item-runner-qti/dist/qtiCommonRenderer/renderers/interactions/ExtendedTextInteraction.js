define(['jquery', 'lodash', 'i18n', 'util/strLimiter', 'handlebars', 'lib/dompurify/purify', 'taoQtiItem/qtiCommonRenderer/helpers/container', 'taoQtiItem/qtiCommonRenderer/helpers/instructions/instructionManager', 'ckeditor', 'taoQtiItem/qtiCommonRenderer/helpers/ckConfigurator', 'taoQtiItem/qtiCommonRenderer/helpers/patternMask', 'ui/tooltip'], function ($$1, _, __, strLimiter, Handlebars, DOMPurify, containerHelper, instructionMgr, ckEditor, ckConfigurator, patternMaskHelper, tooltip) { 'use strict';

    $$1 = $$1 && $$1.hasOwnProperty('default') ? $$1['default'] : $$1;
    _ = _ && _.hasOwnProperty('default') ? _['default'] : _;
    __ = __ && __.hasOwnProperty('default') ? __['default'] : __;
    strLimiter = strLimiter && strLimiter.hasOwnProperty('default') ? strLimiter['default'] : strLimiter;
    Handlebars = Handlebars && Handlebars.hasOwnProperty('default') ? Handlebars['default'] : Handlebars;
    DOMPurify = DOMPurify && DOMPurify.hasOwnProperty('default') ? DOMPurify['default'] : DOMPurify;
    containerHelper = containerHelper && containerHelper.hasOwnProperty('default') ? containerHelper['default'] : containerHelper;
    instructionMgr = instructionMgr && instructionMgr.hasOwnProperty('default') ? instructionMgr['default'] : instructionMgr;
    ckEditor = ckEditor && ckEditor.hasOwnProperty('default') ? ckEditor['default'] : ckEditor;
    ckConfigurator = ckConfigurator && ckConfigurator.hasOwnProperty('default') ? ckConfigurator['default'] : ckConfigurator;
    patternMaskHelper = patternMaskHelper && patternMaskHelper.hasOwnProperty('default') ? patternMaskHelper['default'] : patternMaskHelper;
    tooltip = tooltip && tooltip.hasOwnProperty('default') ? tooltip['default'] : tooltip;

    /**
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2013-2019 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);
     *
     *
     */

    var Helpers0 = hb => {
        //register a i18n helper
        hb.registerHelper('__', function(key) {
            return __(key);
        });

        /**
         * Register dompurify helper
         *
         * https://github.com/cure53/DOMPurify
         * with config SAFE_FOR_TEMPLATES: true
         * to make output safe for template systems
         */
        hb.registerHelper('dompurify', function(context) {
            return DOMPurify.sanitize(context);
        });

        /**
         * Register join helper
         *
         * Example :
         * var values = {a:v1, b:v2, c:v3};
         * Using {{{join attributes '=' ' ' '"'}}} will return : a="v1" b="v2" c="v3"
         * Using {{{join values null ' or ' '*'}}} will return : *v1* or *v2* or *v3*
         */
        hb.registerHelper('join', function(arr, keyValueGlue, fragmentGlue, wrapper) {
            var fragments = [];

            keyValueGlue = typeof keyValueGlue === 'string' ? keyValueGlue : undefined;
            fragmentGlue = typeof fragmentGlue === 'string' ? fragmentGlue : ' ';
            wrapper = typeof wrapper === 'string' ? wrapper : '"';

            _.forIn(arr, function(value, key) {
                var fragment = '';
                if (value !== null || value !== undefined) {
                    if (typeof value === 'boolean') {
                        value = value ? 'true' : 'false';
                    } else if (typeof value === 'object') {
                        value = _.values(value).join(' ');
                    }
                } else {
                    value = '';
                }
                if (keyValueGlue !== undefined) {
                    fragment += key + keyValueGlue;
                }
                fragment += wrapper + value + wrapper;
                fragments.push(fragment);
            });

            return fragments.join(fragmentGlue);
        });

        //register a classic "for loop" helper
        //it also adds a local variable "i" as the index in each iteration loop
        hb.registerHelper('for', function(startIndex, stopIndex, increment, options) {
            var ret = '';
            startIndex = parseInt(startIndex);
            stopIndex = parseInt(stopIndex);
            increment = parseInt(increment);

            for (var i = startIndex; i < stopIndex; i += increment) {
                ret += options.fn(_.extend({}, this, { i: i }));
            }

            return ret;
        });

        hb.registerHelper('equal', function(var1, var2, options) {
            if (var1 == var2) {
                return options.fn(this);
            } else {
                return options.inverse(this);
            }
        });

        // register a "get property" helper
        // it gets the named property from the provided context
        hb.registerHelper('property', function(name, context) {
            return context[name] || '';
        });

        // register an 'includes' helper
        // it checks if value is in array
        hb.registerHelper('includes', function(haystack, needle, options) {
            if (_.contains(haystack, needle)) {
                return options.fn(this);
            }
        });
    };

    if (!Helpers0.__initialized) {
      Helpers0(Handlebars);
      Helpers0.__initialized = true;
    }
    var Template = Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
      this.compilerInfo = [4,'>= 1.0.0'];
    helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
      var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

    function program1(depth0,data) {
      
      var buffer = "", stack1;
      buffer += "id=\""
        + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.id)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
        + "\"";
      return buffer;
      }

    function program3(depth0,data) {
      
      var buffer = "", stack1;
      buffer += " "
        + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1['class'])),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
      return buffer;
      }

    function program5(depth0,data) {
      
      var buffer = "", stack1;
      buffer += " lang=\""
        + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1['xml:lang'])),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
        + "\"";
      return buffer;
      }

    function program7(depth0,data) {
      
      var stack1, helper;
      if (helper = helpers.prompt) { stack1 = helper.call(depth0, {hash:{},data:data}); }
      else { helper = (depth0 && depth0.prompt); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
      if(stack1 || stack1 === 0) { return stack1; }
      else { return ''; }
      }

    function program9(depth0,data) {
      
      var buffer = "", stack1, helper, options;
      buffer += "\n        ";
      stack1 = (helper = helpers.equal || (depth0 && depth0.equal),options={hash:{},inverse:self.program(14, program14, data),fn:self.program(10, program10, data),data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.format), "xhtml", options) : helperMissing.call(depth0, "equal", ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.format), "xhtml", options));
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\n    ";
      return buffer;
      }
    function program10(depth0,data) {
      
      var buffer = "", stack1;
      buffer += "\n            ";
      stack1 = helpers.each.call(depth0, (depth0 && depth0.maxStringLoop), {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\n        ";
      return buffer;
      }
    function program11(depth0,data) {
      
      var buffer = "", stack1;
      buffer += "\n                <div class=\"text-container text-"
        + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.format)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
        + " solid";
      stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1['class']), {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\" name=\""
        + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.identifier)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
        + "_"
        + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
        + "\" contenteditable></div>\n            ";
      return buffer;
      }
    function program12(depth0,data) {
      
      
      return " attributes.class";
      }

    function program14(depth0,data) {
      
      var buffer = "", stack1;
      buffer += "\n            ";
      stack1 = helpers.each.call(depth0, (depth0 && depth0.maxStringLoop), {hash:{},inverse:self.noop,fn:self.program(15, program15, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\n        ";
      return buffer;
      }
    function program15(depth0,data) {
      
      var buffer = "", stack1, helper;
      buffer += "\n                <textarea\n                    class=\"text-container text-"
        + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.format)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
        + " solid";
      stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1['class']), {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\"\n                    name=\""
        + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.identifier)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
        + "_"
        + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
        + "\"\n                    ";
      stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.patternMask), {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\n                    aria-labelledby=\"";
      if (helper = helpers.promptId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
      else { helper = (depth0 && depth0.promptId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
      buffer += escapeExpression(stack1)
        + "\"\n                ></textarea>\n            ";
      return buffer;
      }
    function program16(depth0,data) {
      
      var buffer = "", stack1;
      buffer += "pattern=\""
        + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.patternMask)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
        + "\"";
      return buffer;
      }

    function program18(depth0,data) {
      
      var buffer = "", stack1, helper, options;
      buffer += "\n        ";
      stack1 = (helper = helpers.equal || (depth0 && depth0.equal),options={hash:{},inverse:self.program(21, program21, data),fn:self.program(19, program19, data),data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.format), (depth0 && depth0.xhtml), options) : helperMissing.call(depth0, "equal", ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.format), (depth0 && depth0.xhtml), options));
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\n    ";
      return buffer;
      }
    function program19(depth0,data) {
      
      var buffer = "", stack1;
      buffer += "\n        <div class=\"text-container text-"
        + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.format)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
        + " solid";
      stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1['class']), {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\" contenteditable></div>\n        ";
      return buffer;
      }

    function program21(depth0,data) {
      
      var buffer = "", stack1, helper;
      buffer += "\n            <textarea\n                class=\"text-container text-"
        + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.format)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
        + " solid";
      stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1['class']), {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\"\n                ";
      stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.patternMask), {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\n                aria-labelledby=\"";
      if (helper = helpers.promptId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
      else { helper = (depth0 && depth0.promptId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
      buffer += escapeExpression(stack1)
        + "\"\n            ></textarea>\n        ";
      return buffer;
      }

    function program23(depth0,data) {
      
      var buffer = "", stack1, helper, options;
      buffer += "\n            <span class=\"count-chars\">0</span> "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "of", options) : helperMissing.call(depth0, "__", "of", options)))
        + " <span class=\"count-expected-length\">"
        + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.expectedLength)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
        + "</span> "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "characters", options) : helperMissing.call(depth0, "__", "characters", options)))
        + " "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "recommended", options) : helperMissing.call(depth0, "__", "recommended", options)))
        + ".\n        ";
      return buffer;
      }

    function program25(depth0,data) {
      
      var buffer = "", stack1;
      buffer += "\n            ";
      stack1 = helpers['if'].call(depth0, (depth0 && depth0.maxLength), {hash:{},inverse:self.program(28, program28, data),fn:self.program(26, program26, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\n            ";
      stack1 = helpers['if'].call(depth0, (depth0 && depth0.maxWords), {hash:{},inverse:self.program(32, program32, data),fn:self.program(30, program30, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\n        ";
      return buffer;
      }
    function program26(depth0,data) {
      
      var buffer = "", stack1, helper, options;
      buffer += "\n                <span class=\"text-counter-chars\"><span class=\"count-chars\">0</span> "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "of", options) : helperMissing.call(depth0, "__", "of", options)))
        + " <span class=\"count-max-length\">";
      if (helper = helpers.maxLength) { stack1 = helper.call(depth0, {hash:{},data:data}); }
      else { helper = (depth0 && depth0.maxLength); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
      buffer += escapeExpression(stack1)
        + "</span> "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "characters", options) : helperMissing.call(depth0, "__", "characters", options)))
        + " "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "maximum", options) : helperMissing.call(depth0, "__", "maximum", options)))
        + ".</span>\n            ";
      return buffer;
      }

    function program28(depth0,data) {
      
      var buffer = "", stack1, helper, options;
      buffer += "\n                <span class=\"text-counter-chars\" style=\"display: none\"><span class=\"count-chars\">0</span> "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "of", options) : helperMissing.call(depth0, "__", "of", options)))
        + " <span class=\"count-max-length\">";
      if (helper = helpers.maxLength) { stack1 = helper.call(depth0, {hash:{},data:data}); }
      else { helper = (depth0 && depth0.maxLength); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
      buffer += escapeExpression(stack1)
        + "</span> "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "characters", options) : helperMissing.call(depth0, "__", "characters", options)))
        + " "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "maximum", options) : helperMissing.call(depth0, "__", "maximum", options)))
        + ".</span>\n            ";
      return buffer;
      }

    function program30(depth0,data) {
      
      var buffer = "", stack1, helper, options;
      buffer += "\n                <span class=\"text-counter-words\"><span class=\"count-words\">0</span> "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "of", options) : helperMissing.call(depth0, "__", "of", options)))
        + " <span class=\"count-max-words\">";
      if (helper = helpers.maxWords) { stack1 = helper.call(depth0, {hash:{},data:data}); }
      else { helper = (depth0 && depth0.maxWords); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
      buffer += escapeExpression(stack1)
        + "</span> "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "words", options) : helperMissing.call(depth0, "__", "words", options)))
        + " "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "maximum", options) : helperMissing.call(depth0, "__", "maximum", options)))
        + ".</span>\n            ";
      return buffer;
      }

    function program32(depth0,data) {
      
      var buffer = "", stack1, helper, options;
      buffer += "\n                <span class=\"text-counter-words\" style=\"display: none\"><span class=\"count-words\">0</span> "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "of", options) : helperMissing.call(depth0, "__", "of", options)))
        + " <span class=\"count-max-words\">";
      if (helper = helpers.maxWords) { stack1 = helper.call(depth0, {hash:{},data:data}); }
      else { helper = (depth0 && depth0.maxWords); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
      buffer += escapeExpression(stack1)
        + "</span> "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "words", options) : helperMissing.call(depth0, "__", "words", options)))
        + " "
        + escapeExpression((helper = helpers.__ || (depth0 && depth0.__),options={hash:{},data:data},helper ? helper.call(depth0, "maximum", options) : helperMissing.call(depth0, "__", "maximum", options)))
        + ".</span>\n            ";
      return buffer;
      }

      buffer += "<div ";
      stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.id), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += " class=\"qti-interaction qti-blockInteraction qti-extendedTextInteraction";
      stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1['class']), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\" data-serial=\"";
      if (helper = helpers.serial) { stack1 = helper.call(depth0, {hash:{},data:data}); }
      else { helper = (depth0 && depth0.serial); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
      buffer += escapeExpression(stack1)
        + "\" data-qti-class=\"extendedTextInteraction\"";
      stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1['xml:lang']), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += ">\n    ";
      stack1 = helpers['if'].call(depth0, (depth0 && depth0.prompt), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\n    <div class=\"instruction-container\"></div>\n    ";
      stack1 = helpers['if'].call(depth0, (depth0 && depth0.multiple), {hash:{},inverse:self.program(18, program18, data),fn:self.program(9, program9, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\n    <div class=\"text-counter\">\n        ";
      stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.attributes)),stack1 == null || stack1 === false ? stack1 : stack1.expectedLength), {hash:{},inverse:self.program(25, program25, data),fn:self.program(23, program23, data),data:data});
      if(stack1 || stack1 === 0) { buffer += stack1; }
      buffer += "\n    </div>\n</div>\n";
      return buffer;
      });
    function tpl(data, options, asString) {
      var html = Template(data, options);
      return (asString || true) ? html : $(html);
    }

    /*
     * This program is free software; you can redistribute it and/or
     * modify it under the terms of the GNU General Public License
     * as published by the Free Software Foundation; under version 2
     * of the License (non-upgradable).
     *
     * This program is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     * GNU General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with this program; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
     *
     * Copyright (c) 2014 (original work) Open Assessment Technlogies SA (under the project TAO-PRODUCT);
     *
     */

    /**
     * Init rendering, called after template injected into the DOM
     * All options are listed in the QTI v2.1 information model:
     * http://www.imsglobal.org/question/qtiv2p1/imsqti_infov2p1.html#element10296
     *
     * @param {Object} interaction - the extended text interaction model
     * @returns {Promise} rendering is async
     */
    var render = function render(interaction) {
        return new Promise(function (resolve, reject) {
            var $el, expectedLength, minStrings, patternMask, placeholderType, editor;
            var _styleUpdater, themeLoaded, _getNumStrings;
            var $container = containerHelper.get(interaction);

            var multiple = _isMultiple(interaction);
            var limiter = inputLimiter(interaction);

            var placeholderText = interaction.attr('placeholderText');

            var toolbarType = 'extendedText';
            var ckOptions = {
                resize_enabled: true,
                secure: location.protocol === 'https:',
                forceCustomDomain: true
            };

            if (!multiple) {
                $el = $container.find('textarea');
                if (placeholderText) {
                    $el.attr('placeholder', placeholderText);
                }
                if (_getFormat(interaction) === 'xhtml') {
                    _styleUpdater = function () {
                        var qtiItemStyle, $editorBody, qtiItem;

                        if (editor.document) {
                            qtiItem = $$1('.qti-item').get(0);
                            qtiItemStyle = qtiItem.currentStyle || window.getComputedStyle(qtiItem);

                            if (editor.document.$ && editor.document.$.body) {
                                $editorBody = $$1(editor.document.$.body);
                            } else {
                                $editorBody = $$1(editor.document.getBody().$);
                            }

                            $editorBody.css({
                                'background-color': 'transparent',
                                color: qtiItemStyle.color
                            });
                        }
                    };
                    themeLoaded = function () {
                        _styleUpdater();
                    };

                    editor = _setUpCKEditor(interaction, ckOptions);
                    if (!editor) {
                        reject('Unable to instantiate ckEditor');
                    }

                    editor.on('instanceReady', function () {
                        _styleUpdater();

                        //TAO-6409, disable navigation from cke toolbar
                        if (editor.container && editor.container.$) {
                            $$1(editor.container.$).addClass('no-key-navigation');
                        }

                        //it seems there's still something done after loaded, so resolved must be defered
                        _.delay(resolve, 300);
                    });
                    if (editor.status === 'ready' || editor.status === 'loaded') {
                        _.defer(resolve);
                    }
                    editor.on('configLoaded', function () {
                        editor.config = ckConfigurator.getConfig(editor, toolbarType, ckOptions);

                        if (limiter.enabled) {
                            limiter.listenTextInput();
                        }
                    });
                    editor.on('change', function () {
                        containerHelper.triggerResponseChangeEvent(interaction, {});
                    });

                    $$1(document).on('themechange.themeloader', themeLoaded);
                } else {
                    $el.on('keyup.commonRenderer change.commonRenderer', function () {
                        containerHelper.triggerResponseChangeEvent(interaction, {});
                    });

                    if (limiter.enabled) {
                        limiter.listenTextInput();
                    }

                    resolve();
                }

                //multiple inputs
            } else {
                $el = $container.find('input');
                minStrings = interaction.attr('minStrings');
                expectedLength = interaction.attr('expectedLength');
                patternMask = interaction.attr('patternMask');

                //setting the checking for minimum number of answers
                if (minStrings) {
                    //get the number of filled inputs
                    _getNumStrings = function ($element) {
                        var num = 0;
                        $element.each(function () {
                            if ($$1(this).val() !== '') {
                                num++;
                            }
                        });

                        return num;
                    };

                    minStrings = parseInt(minStrings, 10);
                    if (minStrings > 0) {
                        $el.on('blur.commonRenderer', function () {
                            setTimeout(function () {
                                //checking if the user was clicked outside of the input fields

                                //TODO remove notifications in favor of instructions

                                if (!$el.is(':focus') && _getNumStrings($el) < minStrings) {
                                    instructionMgr.appendNotification(
                                        interaction,
                                        __('The minimum number of answers is ') + ' : ' + minStrings,
                                        'warning'
                                    );
                                }
                            }, 100);
                        });
                    }
                }

                //set the fields width
                if (expectedLength) {
                    expectedLength = parseInt(expectedLength, 10);

                    if (expectedLength > 0) {
                        $el.each(function () {
                            $$1(this).css('width', expectedLength + 'em');
                        });
                    }
                }

                //set the fields pattern mask
                if (patternMask) {
                    $el.each(function () {
                        _setPattern($$1(this), patternMask);
                    });
                }

                //set the fields placeholder
                if (placeholderText) {
                    /**
                     * The type of the fileds placeholder:
                     * multiple - set placeholder for each field
                     * first - set placeholder only for first field
                     * none - dont set placeholder
                     */
                    placeholderType = 'first';

                    if (placeholderType === 'multiple') {
                        $el.each(function () {
                            $$1(this).attr('placeholder', placeholderText);
                        });
                    } else if (placeholderType === 'first') {
                        $el.first().attr('placeholder', placeholderText);
                    }
                }
                resolve();
            }
        });
    };

    /**
     * Reset the textarea / ckEditor
     * @param {Object} interaction - the extended text interaction model
     */
    var resetResponse = function (interaction) {
        if (_getFormat(interaction) === 'xhtml') {
            _getCKEditor(interaction).setData('');
        } else {
            containerHelper.get(interaction).find('input, textarea').val('');
        }
    };

    /**
     * Set the response to the rendered interaction.
     *
     * The response format follows the IMS PCI recommendation :
     * http://www.imsglobal.org/assessment/pciv1p0cf/imsPCIv1p0cf.html#_Toc353965343
     *
     * Available base types are defined in the QTI v2.1 information model:
     * http://www.imsglobal.org/question/qtiv2p1/imsqti_infov2p1.html#element10296
     *
     * @param {Object} interaction - the extended text interaction model
     * @param {object} response
     */
    var setResponse = function (interaction, response) {
        var _setMultipleVal = function (identifier, value) {
            interaction
                .getContainer()
                .find('#' + identifier)
                .val(value);
        };

        var baseType = interaction.getResponseDeclaration().attr('baseType');

        if (response.base && response.base[baseType] !== undefined) {
            setText(interaction, response.base[baseType]);
        } else if (response.list && response.list[baseType]) {
            for (var i in response.list[baseType]) {
                var serial = response.list.serial === undefined ? '' : response.list.serial[i];
                _setMultipleVal(serial + '_' + i, response.list[baseType][i]);
            }
        } else {
            throw new Error('wrong response format in argument.');
        }
    };

    /**
     * Return the response of the rendered interaction
     *
     * The response format follows the IMS PCI recommendation :
     * http://www.imsglobal.org/assessment/pciv1p0cf/imsPCIv1p0cf.html#_Toc353965343
     *
     * Available base types are defined in the QTI v2.1 information model:
     * http://www.imsglobal.org/question/qtiv2p1/imsqti_infov2p1.html#element10296
     *
     * @param {Object} interaction - the extended text interaction model
     * @returns {object}
     */
    var getResponse = function (interaction) {
        var $container = containerHelper.get(interaction);
        var attributes = interaction.getAttributes();
        var responseDeclaration = interaction.getResponseDeclaration();
        var baseType = responseDeclaration.attr('baseType');
        var numericBase = attributes.base || 10;
        var multiple = !!(
            attributes.maxStrings &&
            (responseDeclaration.attr('cardinality') === 'multiple' ||
                responseDeclaration.attr('cardinality') === 'ordered')
        );
        var ret = multiple ? { list: {} } : { base: {} };
        var values;
        var value = '';

        if (multiple) {
            values = [];

            $container.find('input').each(function (i) {
                var $el = $$1(this);

                if (attributes.placeholderText && $el.val() === attributes.placeholderText) {
                    values[i] = '';
                } else {
                    if (baseType === 'integer') {
                        values[i] = parseInt($el.val(), numericBase);
                        values[i] = isNaN(values[i]) ? '' : values[i];
                    } else if (baseType === 'float') {
                        values[i] = parseFloat($el.val());
                        values[i] = isNaN(values[i]) ? '' : values[i];
                    } else if (baseType === 'string') {
                        values[i] = $el.val();
                    }
                }
            });

            ret.list[baseType] = values;
        } else {
            if (attributes.placeholderText && _getTextareaValue(interaction) === attributes.placeholderText) {
                value = '';
            } else {
                if (baseType === 'integer') {
                    value = parseInt(_getTextareaValue(interaction), numericBase);
                } else if (baseType === 'float') {
                    value = parseFloat(_getTextareaValue(interaction));
                } else if (baseType === 'string') {
                    value = _getTextareaValue(interaction, true);
                }
            }

            ret.base[baseType] = isNaN(value) && typeof value === 'number' ? '' : value;
        }

        return ret;
    };

    /**
     * Creates an input limiter object
     * @param {Object} interaction - the extended text interaction
     * @returns {Object} the limiter
     */
    function inputLimiter(interaction) {
        var $container = containerHelper.get(interaction);
        var expectedLength = interaction.attr('expectedLength');
        var expectedLines = interaction.attr('expectedLines');
        var patternMask = interaction.attr('patternMask');
        var patternRegEx;
        var $textarea, $charsCounter, $wordsCounter, maxWords, maxLength, $maxLengthCounter, $maxWordsCounter;
        var enabled = false;

        if (expectedLength || expectedLines || patternMask) {
            enabled = true;

            $textarea = $$1('.text-container', $container);
            $charsCounter = $$1('.count-chars', $container);
            $wordsCounter = $$1('.count-words', $container);
            $maxLengthCounter = $$1('.count-max-length', $container);
            $maxWordsCounter = $$1('.count-max-words', $container);

            if (patternMask !== '') {
                maxWords = patternMaskHelper.parsePattern(patternMask, 'words');
                maxLength = patternMaskHelper.parsePattern(patternMask, 'chars');
                maxWords = _.isNaN(maxWords) ? 0 : maxWords;
                maxLength = _.isNaN(maxLength) ? 0 : maxLength;
                if (!maxLength && !maxWords) {
                    patternRegEx = new RegExp(patternMask);
                }
                $maxLengthCounter.text(maxLength);
                $maxWordsCounter.text(maxWords);
            }
        }

        /**
         * The limiter instance
         */
        var limiter = {
            /**
             * Is the limiter enabled regarding the interaction configuration
             */
            enabled: enabled,

            /**
             * Listen for text input into the interaction and limit it if necessary
             */
            listenTextInput: function listenTextInput() {
                var self = this;

                var ignoreKeyCodes = [
                    8, // backspace
                    16, // shift
                    17, // control
                    46, // delete
                    37, // arrow left
                    38, // arrow up
                    39, // arrow right
                    40, // arrow down
                    35, // home
                    36, // end

                    // ckeditor specific:
                    1114177, // home
                    3342401, // Shift + home
                    1114181, // end
                    3342405, // Shift + end

                    2228232, // Shift + backspace
                    2228261, // Shift + arrow left
                    4456485, // Alt   + arrow left
                    2228262, // Shift + arrow up
                    2228263, // Shift + arrow right
                    4456487, // Alt   + arrow right
                    2228264, // Shift + arrow down

                    1114120, // Ctrl + backspace
                    1114177, // Ctrl + a
                    1114202, // Ctrl + z
                    1114200 // Ctrl + x
                ];
                var triggerKeyCodes = [
                    32, // space
                    13, // enter
                    2228237 // shift + enter in ckEditor
                ];
                var cke;

                var invalidToolip = tooltip.error($container, __('This is not a valid answer'), {
                    position: 'bottom',
                    trigger: 'manual'
                });
                var patternHandler = function patternHandler(e) {
                    var isCke = _getFormat(interaction) === 'xhtml';
                    var newValue;
                    if (patternRegEx) {
                        if (isCke) {
                            // cke has its own object structure
                            newValue = this.getData();
                        } else {
                            // covers input
                            newValue = e.currentTarget.value;
                        }

                        if (!newValue) {
                            return false;
                        }
                        _.debounce(function () {
                            if (!patternRegEx.test(newValue)) {
                                $container.addClass('invalid');
                                $container.show();
                                invalidToolip.show();
                                containerHelper.triggerResponseChangeEvent(interaction);
                            } else {
                                $container.removeClass('invalid');
                                invalidToolip.dispose();
                            }
                        }, 400)();
                    }
                };

                /**
                 * This part works on keyboard input
                 *
                 * @param e
                 * @returns {boolean}
                 */
                var keyLimitHandler = function keyLimitHandler(e) {
                    var keyCode = e && e.data ? e.data.keyCode : e.which;
                    if (
                        !_.contains(ignoreKeyCodes, keyCode) &&
                        ((maxWords && self.getWordsCount() >= maxWords && _.contains(triggerKeyCodes, keyCode)) ||
                            (maxLength && self.getCharsCount() >= maxLength))
                    ) {
                        if (e.cancel) {
                            e.cancel();
                        } else {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                        }
                        return false;
                    }
                    _.defer(function () {
                        self.updateCounter();
                    });
                };

                /**
                 * This part works on drop or paste
                 * @param e
                 */
                var nonKeyLimitHandler = function nonKeyLimitHandler(e) {
                    var newValue;
                    var oldValue = _getTextareaValue(interaction);
                    var isCke = _getFormat(interaction) === 'xhtml';

                    if (typeof $$1(e.target).attr('data-clipboard') === 'string') {
                        newValue = $$1(e.target).attr('data-clipboard');
                    } else if (isCke) {
                        // cke has its own object structure
                        newValue = e.data.dataValue;
                    } else {
                        // covers input via paste or drop
                        newValue = e.originalEvent.clipboardData
                            ? e.originalEvent.clipboardData.getData('text')
                            : e.originalEvent.dataTransfer.getData('text') ||
                              e.originalEvent.dataTransfer.getData('text/plain') ||
                              '';
                    }

                    // prevent insertion of non-limited data
                    if (e.cancel) {
                        e.cancel();
                    } else {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }

                    if (!newValue) {
                        return false;
                    }

                    // limit by word or character count if required
                    if (!_.isNull(maxWords)) {
                        newValue = strLimiter.limitByWordCount(newValue, maxWords - self.getWordsCount());
                    } else if (!_.isNull(maxLength)) {
                        newValue = strLimiter.limitByCharCount(newValue, maxLength - self.getCharsCount());
                    }

                    // insert the cut-off text
                    if (isCke) {
                        _getCKEditor(interaction).insertHtml(newValue);
                    } else {
                        let elements = containerHelper.get(interaction).find('textarea');
                        let el = elements[0];
                        let { selectionStart: start, selectionEnd: end, value: text } = el;
                        elements.val(text.substring(0, start) + newValue + text.substring(end, text.length));
                        el.focus();
                        el.selectionStart = start + newValue.length;
                        el.selectionEnd = el.selectionStart;
                    }

                    _.defer(function () {
                        self.updateCounter();
                    });
                };

                if (_getFormat(interaction) === 'xhtml') {
                    cke = _getCKEditor(interaction);
                    cke.on('key', keyLimitHandler);
                    cke.on('change', patternHandler);
                    cke.on('paste', nonKeyLimitHandler);
                    // @todo: drop requires cke 4.5
                    // cke.on('drop', nonKeyLimitHandler);
                } else {
                    $textarea
                        .on('keyup.commonRenderer', patternHandler)
                        .on('keydown.commonRenderer', keyLimitHandler)
                        .on('paste.commonRenderer drop.commonRenderer', nonKeyLimitHandler);
                }
            },

            /**
             * Get the number of words that are actually written in the response field
             * @return {Number} number of words
             */
            getWordsCount: function getWordsCount() {
                var value = _getTextareaValue(interaction) || '';
                if (_.isEmpty(value)) {
                    return 0;
                }
                // leading and trailing white space don't qualify as words
                return value.trim().replace(/\s+/gi, ' ').split(' ').length;
            },

            /**
             * Get the number of characters that are actually written in the response field
             * @return {Number} number of characters
             */
            getCharsCount: function getCharsCount() {
                var value = _getTextareaValue(interaction) || '';
                return value.length;
            },

            /**
             * Update the counter element
             */
            updateCounter: function udpateCounter() {
                $charsCounter.text(this.getCharsCount());
                $wordsCounter.text(this.getWordsCount());
            }
        };

        return limiter;
    }

    /**
     * return the value of the textarea or ckeditor data
     * @param  {Object} interaction
     * @param  {Boolean} raw Tells if the returned data does not have to be filtered (i.e. XHTML tags not removed)
     * @return {String}             the value
     */
    function _getTextareaValue(interaction, raw) {
        if (_getFormat(interaction) === 'xhtml') {
            return _ckEditorData(interaction, raw);
        } else {
            return containerHelper.get(interaction).find('textarea').val();
        }
    }

    /**
     * Setting the pattern mask for the input, for browsers which doesn't support this feature
     * @param {jQuery} $element
     * @param {string} pattern
     */
    function _setPattern($element, pattern) {
        var patt = new RegExp(pattern);

        //test when some data is entering in the input field
        //@todo plug the validator + tooltip
        $element.on('keyup.commonRenderer', function () {
            $element.removeClass('field-error');
            if (!patt.test($element.val())) {
                $element.addClass('field-error');
            }
        });
    }

    /**
     * Whether or not multiple strings are expected from the candidate to
     * compose a valid response.
     *
     * @param {Object} interaction - the extended text interaction model
     * @returns {Boolean} true if a multiple
     */
    function _isMultiple(interaction) {
        var attributes = interaction.getAttributes();
        var response = interaction.getResponseDeclaration();
        return !!(
            attributes.maxStrings &&
            (response.attr('cardinality') === 'multiple' || response.attr('cardinality') === 'ordered')
        );
    }

    /**
     * Instantiate CkEditor for the interaction
     *
     * @param {Object} interaction - the extended text interaction model
     * @param {Object} [options = {}] - the CKEditor configuration options
     * @returns {Object} the ckEditor instance (or you'll be in trouble
     */
    function _setUpCKEditor(interaction, options) {
        var $container = containerHelper.get(interaction);
        var editor = ckEditor.replace($container.find('.text-container')[0], options || {});
        if (editor) {
            $container.data('editor', editor.name);
            return editor;
        }
    }

    /**
     * Destroy CKEditor
     *
     * @param {Object} interaction - the extended text interaction model
     * @param {Object} [options = {}] - the CKEditor configuration options
     */
    function _destroyCkEditor(interaction) {
        var $container = containerHelper.get(interaction);
        var name = $container.data('editor');
        var editor;
        if (name) {
            editor = ckEditor.instances[name];
        }
        if (editor) {
            editor.destroy();
            $container.removeData('editor');
        }
    }

    /**
     * Gets the CKEditor instance
     * @param {Object} interaction - the extended text interaction model
     * @returns {Object}  CKEditor instance
     */
    function _getCKEditor(interaction) {
        var $container = containerHelper.get(interaction);
        var name = $container.data('editor');

        return ckEditor.instances[name];
    }

    /**
     * get the text content of the ckEditor ( not the entire html )
     * @param  {object} interaction the interaction
     * @param  {Boolean} raw Tells if the returned data does not have to be filtered (i.e. XHTML tags not removed)
     * @returns {string}             text content of the ckEditor
     */
    function _ckEditorData(interaction, raw) {
        var editor = _getCKEditor(interaction);
        var data = (editor && editor.getData()) || '';

        if (!raw) {
            data = _stripTags(data);
        }

        return data;
    }

    /**
     * Remove HTML tags from a string
     * @param {String} str
     * @returns {String}
     */
    function _stripTags(str) {
        var tempNode = document.createElement('div');
        tempNode.innerHTML = str;
        return tempNode.textContent;
    }

    /**
     * Get the interaction format
     * @param {Object} interaction - the extended text interaction model
     * @returns {String} format in 'plain', 'xhtml', 'preformatted'
     */
    function _getFormat(interaction) {
        var format = interaction.attr('format');
        if (_.contains(['plain', 'xhtml', 'preformatted'], format)) {
            return format;
        }
        return 'plain';
    }

    function enable(interaction) {
        var $container = containerHelper.get(interaction);
        var editor;

        $container.find('input, textarea').removeAttr('disabled');

        if (_getFormat(interaction) === 'xhtml') {
            editor = _getCKEditor(interaction);
            if (editor) {
                if (editor.status === 'ready') {
                    editor.setReadOnly(false);
                } else {
                    editor.readOnly = false;
                }
            }
        }
    }

    function disable(interaction) {
        var $container = containerHelper.get(interaction);
        var editor;

        $container.find('input, textarea').attr('disabled', 'disabled');

        if (_getFormat(interaction) === 'xhtml') {
            editor = _getCKEditor(interaction);
            if (editor) {
                if (editor.status === 'ready') {
                    editor.setReadOnly(true);
                } else {
                    editor.readOnly = true;
                }
            }
        }
    }

    function clearText(interaction) {
        setText(interaction, '');
    }

    function setText(interaction, text) {
        var limiter = inputLimiter(interaction);
        if (_getFormat(interaction) === 'xhtml') {
            try {
                _getCKEditor(interaction).setData(text, function () {
                    if (limiter.enabled) {
                        limiter.updateCounter();
                    }
                });
            } catch (e) {
                console.error('setText error', e);
            }
        } else {
            containerHelper.get(interaction).find('textarea').val(text);
            if (limiter.enabled) {
                limiter.updateCounter();
            }
        }
    }

    /**
     * Clean interaction destroy
     * @param {Object} interaction
     */
    function destroy(interaction) {
        var $container = containerHelper.get(interaction);
        var $el = $container.find('input, textarea');

        if (_getFormat(interaction) === 'xhtml') {
            _destroyCkEditor(interaction);
        }

        //remove event
        $el.off('.commonRenderer');
        $$1(document).off('.commonRenderer');

        //remove instructions
        instructionMgr.removeInstructions(interaction);

        //remove all references to a cache container
        containerHelper.reset(interaction);
    }

    /**
     * Set the interaction state. It could be done anytime with any state.
     *
     * @param {Object} interaction - the interaction instance
     * @param {Object} state - the interaction state
     */
    function setState(interaction, state) {
        if (_.isObject(state)) {
            if (state.response) {
                try {
                    interaction.setResponse(state.response);
                } catch (e) {
                    interaction.resetResponse();
                    throw e;
                }
            }
        }
    }

    /**
     * Get the interaction state.
     *
     * @param {Object} interaction - the interaction instance
     * @returns {Object} the interaction current state
     */
    function getState(interaction) {
        var state = {};
        var response = interaction.getResponse();

        if (response) {
            state.response = response;
        }
        return state;
    }

    function getCustomData(interaction, data) {
        var pattern = interaction.attr('patternMask'),
            maxWords = parseInt(patternMaskHelper.parsePattern(pattern, 'words')),
            maxLength = parseInt(patternMaskHelper.parsePattern(pattern, 'chars')),
            expectedLength = parseInt(interaction.attr('expectedLines'), 10);
        return _.merge(data || {}, {
            maxWords: !isNaN(maxWords) ? maxWords : 0,
            maxLength: !isNaN(maxLength) ? maxLength : 0,
            attributes: !isNaN(expectedLength) ? { expectedLength: expectedLength * 72 } : undefined
        });
    }

    /**
     * Expose the common renderer for the extended text interaction
     * @exports qtiCommonRenderer/renderers/interactions/ExtendedTextInteraction
     */
    var ExtendedTextInteraction = {
        qtiClass: 'extendedTextInteraction',
        template: tpl,
        render: render,
        getContainer: containerHelper.get,
        setResponse: setResponse,
        getResponse: getResponse,
        getData: getCustomData,
        resetResponse: resetResponse,
        destroy: destroy,
        getState: getState,
        setState: setState,

        enable: enable,
        disable: disable,
        clearText: clearText,
        setText: setText
    };

    return ExtendedTextInteraction;

});
